<!doctype html>



  


<html class="theme-next mist use-motion" lang="default">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="true" />







  <meta name="baidu-site-verification" content="true" />







  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="fuzzing," />





  <link rel="alternate" href="/atom.xml" title="PCB博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="Interesting FuzzingCoverage-based Greybox Fuzzing as Markov Chain(CCS 16) paper source code   Search Strategy Power Schedule 通过改变前面两个方法来使程序更大概率地走到low-density region.  T-Fuzz: fuzzing by program transf">
<meta name="keywords" content="fuzzing">
<meta property="og:type" content="article">
<meta property="og:title" content="fuzzing related work">
<meta property="og:url" content="http://bin2415.github.io/2018/10/05/fuzzing/index.html">
<meta property="og:site_name" content="PCB博客">
<meta property="og:description" content="Interesting FuzzingCoverage-based Greybox Fuzzing as Markov Chain(CCS 16) paper source code   Search Strategy Power Schedule 通过改变前面两个方法来使程序更大概率地走到low-density region.  T-Fuzz: fuzzing by program transf">
<meta property="og:image" content="http://bin2415.github.io/2018/10/05/fuzzing/image/s1.png">
<meta property="og:image" content="https://github.com/bin2415/fuzzing_paper/blob/master/image/afl_overview.png">
<meta property="og:image" content="https://github.com/bin2415/fuzzing_paper/blob/master/image/hawkeye_overview.png">
<meta property="og:updated_time" content="2018-10-05T07:10:21.821Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="fuzzing related work">
<meta name="twitter:description" content="Interesting FuzzingCoverage-based Greybox Fuzzing as Markov Chain(CCS 16) paper source code   Search Strategy Power Schedule 通过改变前面两个方法来使程序更大概率地走到low-density region.  T-Fuzz: fuzzing by program transf">
<meta name="twitter:image" content="http://bin2415.github.io/2018/10/05/fuzzing/image/s1.png">

<meta name="google-site-verification" content="6X0VEc7S4OCLuVOpAVhTrqQS6qCLzeJWET8siPhU0IE" />

<meta name="baidu-site-verification" content="KlrRozk5Oe" />


<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://bin2415.github.io/2018/10/05/fuzzing/"/>





  <title>fuzzing related work | PCB博客</title>
</head>


																										
<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

																										

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', '[object Object]', 'auto');
  ga('send', 'pageview');
</script>












  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner">

<div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">PCB博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">快乐记录每一天</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>




 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://bin2415.github.io/2018/10/05/fuzzing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="binpang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PCB博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">fuzzing related work</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-05T15:09:11+08:00">
                2018-10-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/fuzzing/" itemprop="url" rel="index">
                    <span itemprop="name">fuzzing</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a class="cloud-tie-join-count" href="/2018/10/05/fuzzing/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count join-count" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/10/05/fuzzing/" class="leancloud_visitors" data-flag-title="fuzzing related work">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          
		  
        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Interesting-Fuzzing"><a href="#Interesting-Fuzzing" class="headerlink" title="Interesting Fuzzing"></a>Interesting Fuzzing</h1><h2 id="Coverage-based-Greybox-Fuzzing-as-Markov-Chain-CCS-16"><a href="#Coverage-based-Greybox-Fuzzing-as-Markov-Chain-CCS-16" class="headerlink" title="Coverage-based Greybox Fuzzing as Markov Chain(CCS 16)"></a>Coverage-based Greybox Fuzzing as Markov Chain(CCS 16)</h2><ul>
<li><a href="https://github.com/bin2415/fuzzing_paper/tree/master/paper/CCS16_aflfast.pdf" target="_blank" rel="external">paper</a></li>
<li><a href="https://github.com/mboehme/aflfast" target="_blank" rel="external">source code</a></li>
</ul>
<ul>
<li>Search Strategy</li>
<li>Power Schedule</li>
<li>通过改变前面两个方法来使程序更大概率地走到low-density region.</li>
</ul>
<h2 id="T-Fuzz-fuzzing-by-program-transformation-S-amp-P-18"><a href="#T-Fuzz-fuzzing-by-program-transformation-S-amp-P-18" class="headerlink" title="T-Fuzz: fuzzing by program transformation(S&amp;P 18)"></a>T-Fuzz: fuzzing by program transformation(S&amp;P 18)</h2><ul>
<li><a href="https://github.com/bin2415/fuzzing_paper/tree/master/paper/oakland18_T-Fuzz.pdf" target="_blank" rel="external">paper</a></li>
<li><a href="https://github.com/HexHive/T-Fuzz" target="_blank" rel="external">source code</a></li>
</ul>
<ul>
<li>Fuzzer: T-Fuzz uses an existing coverage guided fuzzer to generate inputs. T-Fuzz depends on the fuzzer to keep track of the paths taken by all the generated inputs and realtime status infomation regarding whether it is “stuck”. As output, the fuzzer produces all the generated inputs. Any identified crashing inputs are recorded for further anlysis.</li>
<li>Program Transformer: When the fuzzer gets “stuck”, T-Fuzz invokes its Program Transformer to generate tranformed programs. Using the inputs generated by the fuzzer, the Program Transformer first traces the program under test to detect the NCC candidates and then transforms copies of the program by removing certain detected NCC candidates.</li>
<li>Crash Analyzer: For crashing inputs found against the transformed programs, the Crash Analyser filters false positives using a symbolic-execution based analysis technique.</li>
</ul>
<h3 id="T-Fuzz-Design"><a href="#T-Fuzz-Design" class="headerlink" title="T-Fuzz Design"></a>T-Fuzz Design</h3><ul>
<li>Detecting NCCs: NCCs are those sanity checks which are present in the program logic to filter some orthogonal data, e.g., the check for a magic value in the decompressor example above. NCCs can be removed without triggering spurious bugs as they are not intended to prevent bugs. This paper uses a lightweight method to find the NCCs. Firstly, they define the concept of boundary edges: the edges connecting the nodes that were covered by the fuzzer-generated inputs and those that were not. The method that find the NCCs in this paper is over-approximation, so they find two ways to prune undesired NCC condidates.</li>
<li>Program Transformation: After finding NCCs, T-Fuzz should “remove” the NCCs conditions to guide the execution to the another branch. T-Fuzz transforms programs by replacing the detected NCC candidates with negated conditional jump.</li>
<li>Filtering out False Positives and Reproducing Bugs: As the removed NCC candidates might be meaningful guards in the original program(as opposed to, e.g., magic number checks), removing detected NCC edges might introduce new bugs in the transformed program. Consequently, T-Fuzz’s Crash Analyzer verifies that each bug in the transformaed program is also present in the original proram, thus filtering out false positives. The Crash Analyser uses a transformation-aware combination of the preconstrained tracing technique leveraged by Driller and the Path Kneading techniques proposed by ShellSwap to collect path constraints of the original program by tracing the program path leading to a crash in the transformed program.</li>
</ul>
<h2 id="CollAFL-Path-Sensitive-Fuzzing-S-amp-P-18"><a href="#CollAFL-Path-Sensitive-Fuzzing-S-amp-P-18" class="headerlink" title="CollAFL: Path Sensitive Fuzzing(S&amp;P 18)"></a>CollAFL: Path Sensitive Fuzzing(S&amp;P 18)</h2><ul>
<li><a href="https://github.com/bin2415/fuzzing_paper/tree/master/paper/oakland18_collafl.pdf" target="_blank" rel="external">paper</a></li>
<li>source code has not been found.</li>
</ul>
<p>该paper主要对AFL有两个改进:</p>
<ul>
<li>AFL是coverage-based greybox fuzzing，它通过对源程序进行轻量级的插桩，来跟踪每次fuzzing的input覆盖哪些路径，然后将路径hash，从而判断每个input是否到达了一个新的路径，如果到达新的路径，则说明该input较好，将该input作为seed。但由于hash可能会发生collision，可能会导致某些input到达新的路径，却没有将该input作为seed。该paper主要针对这一点，采用了一个新的算法，解决了路径hash collision问题，产生的效果也是比较显著的。</li>
<li>提供了一些策略来将seed进行排序，促使fuzzer去探索没有到达的路径。具体做法就是如果某条路径有很多没有探索到的邻居分支，则对该input进行更多的变异；如果某条路径有很多没有探索到的邻居后代，则对该input产生更多的变异。还有一个策略来帮助发现更多的漏洞：如果某条路径进行更多的内存访问，则对该input产生更多的变异。</li>
</ul>
<p>我个人认为，该论文的主要贡献是提供了一个机制来解决路径的hash collision问题，使得coverage判断更加准确。</p>
<h3 id="AFL-Coverage-Measurements"><a href="#AFL-Coverage-Measurements" class="headerlink" title="AFL Coverage Measurements"></a>AFL Coverage Measurements</h3><p>AFL使用bitmap(默认64KB)来跟踪edge coverage。没一个字节都对应特定edge的hit count。AFL通过对每个basic block进行插桩，为每个basic block都随机分配一个id，当执行每条路径时，对该路径上的每个basic block都进行如下操作:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cur_location= &lt;COMPILE_TIME_RANDOM&gt;;</div><div class="line">shared_mem[cur_location ^ prev_location]++;</div><div class="line">prev_location = cur_location &gt;&gt; <span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>其中上面的prev_location右移一位主要是为了区分路径A-&gt;B和B-&gt;A。由于每个basic block的id是随机分配的，所以这种hash方法很容易产生collision，特别当程序比较大的时候，collision rate也越大。</p>
<h3 id="CollAFL’s-Solution-to-Hash-Collision"><a href="#CollAFL’s-Solution-to-Hash-Collision" class="headerlink" title="CollAFL’s Solution to Hash Collision"></a>CollAFL’s Solution to Hash Collision</h3><p>CollAFL通过三种方式来解决hash collision:</p>
<ol>
<li><img src="/2018/10/05/fuzzing/./image/s1.png" alt="公式1"><br>通过贪心算法，为每个basic block分配x和y的值，保证每条edge计算的hash值都是不同的。</li>
<li>如果每个basic block只有一个前继basic block，即只有一条边到达该basic block，所以只需要将该basic block的id来表示该edge即可。</li>
<li>如果前面两种方法无法解决，则动态的时候为每条边分配不同的id。</li>
</ol>
<h2 id="Driller-Argumenting-Fuzzing-Through-Selective-Symbolic-Execution-ndss-16"><a href="#Driller-Argumenting-Fuzzing-Through-Selective-Symbolic-Execution-ndss-16" class="headerlink" title="Driller: Argumenting Fuzzing Through Selective Symbolic Execution(ndss 16)"></a>Driller: Argumenting Fuzzing Through Selective Symbolic Execution(ndss 16)</h2><ul>
<li><a href="https://github.com/bin2415/fuzzing_paper/tree/master/paper/NDSS16_driller.pdf" target="_blank" rel="external">paper</a></li>
<li><a href="https://github.com/shellphish/driller" target="_blank" rel="external">source code</a></li>
</ul>
<p>我们都知道，fuzzing对于一些比较宽松的限制(比如x&gt;0)能够很容易的通过变异产生一些输入达到该条件；而symbolic execution非常擅长求解一下magic value(比如x == deadleaf)。这是一篇比较经典的将concolic execution和fuzzing结合在一起的文章，该文章的主要思想就是先用AFL等Fuzzer根据seed进行变异，来测试程序。当产生的输入一直走某些路径，并没有探测到新的路径时，此时就”stuck”了。这时，就是用concolic execution来产生输入，保证该输入能走到一些新的分支。从而利用concolic execution来辅助fuzz。</p>
<h2 id="VUzzer-Application-aware-Evolutionary-Fuzzing-ndss-17"><a href="#VUzzer-Application-aware-Evolutionary-Fuzzing-ndss-17" class="headerlink" title="VUzzer: Application-aware Evolutionary Fuzzing(ndss 17)"></a>VUzzer: Application-aware Evolutionary Fuzzing(ndss 17)</h2><ul>
<li><a href="https://github.com/bin2415/fuzzing_paper/tree/master/paper/ndss17_vuzzer.pdf" target="_blank" rel="external">paper</a></li>
<li><a href="https://github.com/vusec/vuzzer" target="_blank" rel="external">source code</a></li>
</ul>
<p>Vuzzer是公认的比较好的类AFL fuzzer。它主要利用Data-flow features和Control-flow features来辅助fuzzer变异和进行seed的选择。</p>
<h3 id="Data-flow-features"><a href="#Data-flow-features" class="headerlink" title="Data-flow features"></a>Data-flow features</h3><p>利用dynamic taint analysis 来推断input的结构和类型，以及某段数据在input的偏移。比如，它通过对每个cmp指令进行插桩来判断input的哪些字节与输入有关，并且知道与它比较的另外一个值。同时，Vuzzer也可以对lea指令进行插桩，从而检测<em>index</em>操作是不是与input某些bytes有关。</p>
<h3 id="Control-flow-features"><a href="#Control-flow-features" class="headerlink" title="Control-flow features"></a>Control-flow features</h3><p>Control-flow features可以让Vuzzer推断出执行路径的重要性。比如，某些执行路径最后到达了<em>error-hanling blocks</em>。Vuzzer就通过静态的方法识别出了一下<em>error-handling code</em>。同时，Vuzzer通过对每个basic block赋予特定的权重，来促使fuzzer走到更深的路径中去。</p>
<h2 id="Angora-Efficient-Fuzzing-by-Principled-Search-S-amp-P-18"><a href="#Angora-Efficient-Fuzzing-by-Principled-Search-S-amp-P-18" class="headerlink" title="Angora: Efficient Fuzzing by Principled Search(S&amp;P 18)"></a>Angora: Efficient Fuzzing by Principled Search(S&amp;P 18)</h2><ul>
<li><a href="https://github.com/bin2415/fuzzing_paper/blob/master/paper/oakland18_Angora.pdf" target="_blank" rel="external">paper</a></li>
<li><a href="https://github.com/AngoraFuzzer/Angora" target="_blank" rel="external">source code</a></li>
</ul>
<p>This paper’s contributations:</p>
<ul>
<li><em>Context-sensitive branch coverage.</em> AFL uses context-insensitive branch coverage to approximate program states. This paper adding context information to branch.</li>
<li><em>Scalable byte-level taint tracking.</em> Most path constraints depend on only a few bytes in the input. By tracking which input bytes flow into each path constraint, Angora mutates only these bytes instead of the entire input, therefore reducing the space of exploration substantially.</li>
<li><em>Search based on gradient descent.</em> When mutating the input to satisfy a path constraint. Angora avoids symbolic execution, which is expensive and cannot solve many types of constraints. Instead, Angora uses the gradient descent algorithm popular in machine learning to solve path constraints.</li>
<li><em>Type and shape inference.</em> Many bytes in the input are used collectively as a single value in the program, e.g., a group of four bytes in the input used as a 32-bit signed integer in the program. To allow gradient descent to search efficiently, Angora locates the above group and infers its type.</li>
</ul>
<h2 id="Designing-New-Operating-Primitives-to-Improve-Fuzzing-Performance-CCS-17"><a href="#Designing-New-Operating-Primitives-to-Improve-Fuzzing-Performance-CCS-17" class="headerlink" title="Designing New Operating Primitives to Improve Fuzzing Performance(CCS 17)"></a>Designing New Operating Primitives to Improve Fuzzing Performance(CCS 17)</h2><ul>
<li><a href="https://github.com/bin2415/fuzzing_paper/blob/master/paper/ccs17_prefFuzz.pdf" target="_blank" rel="external">paper</a></li>
<li><a href="https://github.com/sslab-gatech/perf-fuzz" target="_blank" rel="external">source code</a></li>
</ul>
<h3 id="AFL-Overview"><a href="#AFL-Overview" class="headerlink" title="AFL Overview"></a>AFL Overview</h3><p><img src="https://github.com/bin2415/fuzzing_paper/blob/master/image/afl_overview.png" alt="afl-overview"></p>
<ul>
<li>Mutating inputs(1). AFL uses an evolutionary coverage-based mutation technique to generate test cases for discovering new execution paths of the target application. In AFL, an execution path is represented as a sequence of taken branches(i.e., a coverage bitmap) in the target instance for a given input. To track whether a branch is taken, AFL instruments every conditional branch and function entry of the target application at the time of compilation.</li>
<li>Launching the target application(2). Traditional fuzzers call <em>fork()</em> followed by <em>execve()</em> to launch an instance of the target application. This process occurs in every fuzzing loop to deliver a new input to the target application. It is not only time consuming, but also a non-scalable operation. Previous research shows that the majority of fuzzing execution explores only the shallow part of the code and terminates quickly(e.g., because of invalid input format), which results in frequent executions for the input cases. Thus, the cost of fork() and execve() dominates the cost of fuzzing. To mitigate this cost, AFL introduced a fork server, which is similar to a Zygote process in Android that eliminates the heavyweight execve() system call. After instantiating a target application, the fork server waits for a starting signal sent over the pip from the AFL instance. Upon receiving the request, it first clones the already-loaded program using fork() and the child process continues the execution of the original target code immediately from the entry point(i.e., main) with a given input generated for the current fuzzing loop. The parent process waits for the termination of its child, and then informs the AFL process. The AFL process collects the branch coverage of the past execution, and maintains the test input if it is interesting.</li>
<li>Bookkeeping results(3, 4). The fork server also initializes a shared memory(also known as tracing bitmap) between the AFL instance and the target application. The instance records all the coverage information during the execution and writes it to the shared tracing bitmap, which summarizes the branch coverage of the past execution.</li>
<li>Fuzzing in parallel(6). AFL also supports parallel fuzzing to completely utilize resources available on a multi-core machine and expedite the fuzzing process. In this case, each AFL instance independently executes without explicit contention among themselves(i.e., embarrassingly parallel). From the perspective of the design of AFL, the fuzzing operation should linearly scale with increasing core count. Moreover, to avoid apparent contention on file system accesses, each AFL instance works in its private working directory for test cases. At the end of a fuzzing loop, the AFL instance scans the output directories of other instances to learn their test cases, called the <em>syncing phase</em>. For each collaborating neighbor, it keeps a test case identifier, which indicates the last test case it has checked. It figures out all the test cases that have an identifier larger than the reserved one, and re-executes them one by one. If a test case covers a new path that has not been discovered by the instance itself, the test case is copied to its oen directory for further mutation.</li>
</ul>
<h2 id="QSYM-A-Practical-Concolic-Execution-Engine-Tailored-for-Hybrid-Fuzzing-Usenix-18"><a href="#QSYM-A-Practical-Concolic-Execution-Engine-Tailored-for-Hybrid-Fuzzing-Usenix-18" class="headerlink" title="QSYM: A Practical Concolic Execution Engine Tailored for Hybrid Fuzzing(Usenix 18)"></a>QSYM: A Practical Concolic Execution Engine Tailored for Hybrid Fuzzing(Usenix 18)</h2><ul>
<li><a href="https://github.com/bin2415/fuzzing_paper/blob/master/paper/usenix18_qsym.pdf" target="_blank" rel="external">paper</a></li>
<li><a href="https://github.com/sslab-gatech/qsym" target="_blank" rel="external">source code</a></li>
</ul>
<p>该paper是Usenix 18的Distinguished Paper，其主要针对了当前的concolic execution的三个方面进行了优化: Slow Symbolic Emulation, Ineffective Snapshot and Slow and Inflexible Sound Analysis. 从而使得concolic execution更好的适应fuzzing场景。</p>
<h3 id="Motivation-Performance-Bottlenecks"><a href="#Motivation-Performance-Bottlenecks" class="headerlink" title="Motivation: Performance Bottlenecks"></a>Motivation: Performance Bottlenecks</h3><h4 id="Slow-Symbolic-Emulation"><a href="#Slow-Symbolic-Emulation" class="headerlink" title="Slow Symbolic Emulation"></a>Slow Symbolic Emulation</h4><p>现在主流的conclic executors做符号执行的时候是针对IR中间语言做的(比如KLEE的LLVM IR和angr的VEX IR)，对中间语言模拟执行。其<em>采用IR的原因是实现起来比较简单</em>。由于Intel 64位指令集包含1795条指令，所以针对每条指令总结出来符号的语义对于人工来说是一个非常大的工作量，而IR的指令较少(LLVM IR有62条指令)，符号化这些指令相对比较简单。</p>
<p>然而使用IR则引发了额外的overhead。首先，从机器指令到IR的转换本身就有overhead。由于amd64是CISC(complex instruction set computer)，而IR是RISC(reduced instruction set computer)，一般一条amd64的指令需要转换成多条IR指令，拿angr为例，如果将amd64指令转为VEX IR，则平均增加的指令数是4.69倍。其次，采用IR导致basic block level taint。因为由于效率的原因，从native instructions到IR的转换一般是以basic block为单位的，这样就导致无法将单个的native instruction转换成IR，所以也就只能做到哪些basic block需要符号化，而不是具体的某条指令需要符号化。这样做导致的后果就是如果某个basic block中只有一条指令和输入有关需要符号化，则整个basic block都需要符号模拟，这样就会造成很高的overhead。如果没有IR的话就可以做到指令级别的taint，就能够清楚的判断哪些指令需要符号模拟，哪些指令只需native execution，减少了不必要的符号模拟。实验表明，在一个basic block中，只有30%的指令需要符号模拟。</p>
<h4 id="Ineffective-Snapshot"><a href="#Ineffective-Snapshot" class="headerlink" title="Ineffective Snapshot"></a>Ineffective Snapshot</h4><p>snapshot是conclic execution常用的一个技术，它能够保存某条分支前的状态S，当该分支执行完或者”stuck”时，可以从该状态S直接执行另外一个分支，避免了重新执行的overhead。然而snapshot本身就有一些缺点：snapshot需要保存一些外部的状态(文件系统，内存管理系统)，则此时需要对影响外部状态的系统调用进行处理，一般有两个方法: full system concolic execution and External environment modeling。这两个方法都有一些缺陷：第一个方法是由于外部环境比较复杂，实现起来比较难，overhead较高；第二个则是model的system call较少，并且有些system call建模的不够完全。另外由于fuzzing的输入一般不会共享同一个分支，所以snapshot可能对于fuzzing这个场景也不是很好，所以该paper就没有采用snapshot的机制，对于每个输入都会重新执行，对于系统调用，则具体执行。</p>
<h4 id="Slow-and-Inflexible-Sound-Analysis"><a href="#Slow-and-Inflexible-Sound-Analysis" class="headerlink" title="Slow and Inflexible Sound Analysis"></a>Slow and Inflexible Sound Analysis</h4><p>现在的concolic execution是将某条路径上的所有contraints都满足，从而求解出具体的input。然而复杂的contraints可能会导致输入求解不出。所以该paper的一个解决方法就是只求解出部分contraints。</p>
<h1 id="Directed-Fuzzing"><a href="#Directed-Fuzzing" class="headerlink" title="Directed Fuzzing"></a>Directed Fuzzing</h1><h2 id="Directed-Greybox-Fuzzing-CCS-17"><a href="#Directed-Greybox-Fuzzing-CCS-17" class="headerlink" title="Directed Greybox Fuzzing(CCS 17)"></a>Directed Greybox Fuzzing(CCS 17)</h2><ul>
<li><a href="https://github.com/bin2415/fuzzing_paper/tree/master/paper/CCS17_aflgo.pdf" target="_blank" rel="external">paper</a></li>
<li><a href="https://github.com/aflgo/aflgo" target="_blank" rel="external">source code</a></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Input: Seed Input S</div><div class="line"></div><div class="line">repeat</div><div class="line">    s = CHOOSENEXT(S)</div><div class="line">    p = ASSIGNENERGY(s)    <span class="comment">//This paper focus</span></div><div class="line">    <span class="keyword">for</span> i from <span class="number">1</span> to p <span class="keyword">do</span></div><div class="line">        s' = MUTATE_INPUT(s)</div><div class="line">        <span class="keyword">if</span> t' crashes then</div><div class="line">            add s' to Sx</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ISINTERESTING(s') then</div><div class="line">            add s' to S</div><div class="line">        end <span class="keyword">if</span></div><div class="line">    end <span class="keyword">for</span></div><div class="line">until timeout reached <span class="keyword">or</span> <span class="built_in">abort</span>-signal</div><div class="line"></div><div class="line">Output: Crashing Inputs Sx</div></pre></td></tr></table></figure>
<p>类AFL的fuzzing一般步骤如上所示，该paper主要关注于ASSIGNENERGY(s)这一操作，他们通过对不同的seed s赋予不同的energy，即如果一个seed s’产生的trace距离目标基本块targetB较近，则其energy(p)就较大，基于种子s’进行的变异操作就会变多。所以该paper主要有两个contributation: 设计一套算法计算seed s’产生的trace与targetB的距离；通过模拟退火算法来为每个seed s分配energy。</p>
<h2 id="Hawkeye-Towards-a-Desired-Directed-Grey-box-Fuzzer-CCS-18"><a href="#Hawkeye-Towards-a-Desired-Directed-Grey-box-Fuzzer-CCS-18" class="headerlink" title="Hawkeye: Towards a Desired Directed Grey-box Fuzzer(CCS 18)"></a>Hawkeye: Towards a Desired Directed Grey-box Fuzzer(CCS 18)</h2><ul>
<li><a href="https://github.com/bin2415/fuzzing_paper/tree/master/paper/ccs18_hawkeye.pdf" target="_blank" rel="external">paper</a></li>
<li>source code has not been found.</li>
</ul>
<h3 id="Desired-Properties-of-Directed-Fuzzing"><a href="#Desired-Properties-of-Directed-Fuzzing" class="headerlink" title="Desired Properties of Directed Fuzzing"></a>Desired Properties of Directed Fuzzing</h3><ul>
<li>P1. The DGF should define a <strong>robust</strong> distance-based mechanism that can guide the directed fuzzing by avoiding the bias to some traces and considering all traces to the targets.</li>
<li>P2. The DGF should strike a balance between overheads and utilities in static analysis.</li>
<li>P3. The DGF should select and schedule the seeds to rapidly reach target sites. AFL determines how many new inputs(i.e., “energy”) should be generated from a seed input to improve the fuzzing effectiveness(i.e., increase the coverage); this is termed “power scheduling”.</li>
<li>P4. The DGF should adopt an adaptive mutation strategy when the seeds cover the different program states. The desired design is that when a seed has already reached the target sites(including target lines, basic blocks or functions), it should be given less chances for coarse-grained mutations(e.g., chunk replacement).</li>
</ul>
<h3 id="AFLGo’s-Solution"><a href="#AFLGo’s-Solution" class="headerlink" title="AFLGo’s Solution"></a>AFLGo’s Solution</h3><ul>
<li>针对P1，AFLGo只是选择路径最短的那条，然而路径最短的那条可能无法触发某个漏洞。</li>
<li>For P2. AFLGo only considers the explicit call graph information. As a result, function pointers are treated as the external nodes which are ignored during distance calculation. Besides, AFLGo counts the same callee in tis callers only once, and it does not differentiate multiple call patterns between the caller and callee.</li>
<li>For P3. AFLGo applies a simulated annealing based power scheduler: it favors those seeds closer to the targets by assigning more energy to them to be mutated; the applied cooling sechedule initially assigns smaller weight on the effecte of “distance guidance”, until it reaches the “exploitation” phrase. The issue is that there is no prioritization procedure so the newly generated seeds with smaller distance may wait for a long to be mutated.</li>
<li>For P4. The mutation operators of AFLGo come from AFL’s two non-deterministic strategies: 1) havoc, which does purely randomly mutations such as bit flips, bytewise replace, etc; 2) splice, which generates seeds from some random byte parts of two existing seeds. Notably, during runtime AFLGo excludes all the deterministic mutation procedures and relies purely on the power scheduling on havoc/splice strategies.</li>
</ul>
<h3 id="Suggestions-to-improve-DGFs"><a href="#Suggestions-to-improve-DGFs" class="headerlink" title="Suggestions to improve DGFs:"></a>Suggestions to improve DGFs:</h3><ul>
<li>For P1, a more accurate distance definition is needed to retain trace diversity, avoiding the focus on short traces.</li>
<li>For P2, both direct and indirect calls need to be analyzed; various call patterns need to be distinguished during static distance calculation.</li>
<li>For P3, a moderation to the current power scheduling is required. The distance-guided seed prioritization is also needed.</li>
<li>For P4, the DGF needs an adaptive mutation strategy, which optimally applies the fine-grained abd ciarse-graubed nytatuibs wgeb tge dustabce between the seed to the targets is different.</li>
</ul>
<h3 id="Hawkeye’s-Design"><a href="#Hawkeye’s-Design" class="headerlink" title="Hawkeye’s Design"></a>Hawkeye’s Design</h3><p><img src="https://github.com/bin2415/fuzzing_paper/blob/master/image/hawkeye_overview.png" alt="overview"></p>
<p>During fuzzing, the fuzzer selects a seed from a priority seed queue. The fuzzer applies a power scheduling against the seed with the goal of giving those seeds that are considered to be “closer” to the target sites more mutation chances, i.e, energy. Specifically, this is achieved through a power function, which is a combination of the <em>covered function similarity</em> and the <em>basic block trace distance</em>. For each newly generated test seed during mutation, after capturing its execution trace, the fuzzer will calculate the covered function similarity and the basic block trace distance based on the utilities. For each input execution trace, its basic block trace distance is calculated as the accumulated basic block level distances divided by the total number of executed basic blocks; and its covered function similarity is calculated based on the overlapping of current executed functions and the target function trace closure, as well as the function level distance.</p>
<p>After the energy is determined, the fuzzer adaptively allocates mutation budgets on two different categories of mutations according to mutators’ granularities on the seed(coarse-grained mutations and fine-grained mutations). Afterwards, the fuzzer evaluates the newly generated seeds to prioritize those that have more energy or that have reached the target functions.</p>
<h1 id="Fuzzing-Machine-Learning-Model"><a href="#Fuzzing-Machine-Learning-Model" class="headerlink" title="Fuzzing Machine Learning Model"></a>Fuzzing Machine Learning Model</h1><h2 id="TensorFuzz-Debugging-Neural-Networks-with-Coverage-Guided-Fuzzing-18"><a href="#TensorFuzz-Debugging-Neural-Networks-with-Coverage-Guided-Fuzzing-18" class="headerlink" title="TensorFuzz: Debugging Neural Networks with Coverage-Guided Fuzzing(18)"></a>TensorFuzz: Debugging Neural Networks with Coverage-Guided Fuzzing(18)</h2><ul>
<li><a href="https://github.com/bin2415/fuzzing_paper/tree/master/paper/tensorfuzz.pdf" target="_blank" rel="external">paper</a></li>
<li><a href="https://github.com/brain-research/tensorfuzz" target="_blank" rel="external">source code</a></li>
</ul>
<h2 id="Coverage-Guided-Fuzzing-for-Deep-Neural-Networks-18"><a href="#Coverage-Guided-Fuzzing-for-Deep-Neural-Networks-18" class="headerlink" title="Coverage-Guided Fuzzing for Deep Neural Networks(18)"></a>Coverage-Guided Fuzzing for Deep Neural Networks(18)</h2><ul>
<li><a href="https://github.com/bin2415/fuzzing_paper/blob/master/paper/18_coverage-guided-fuzzing-for-deep-neural-networks.pdf" target="_blank" rel="external">paper</a></li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/fuzzing/" rel="tag"># fuzzing</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/09/27/os-tutorial/" rel="next" title="os tutorial">
                <i class="fa fa-chevron-left"></i> os tutorial
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        
<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="binpang" />
          <p class="site-author-name" itemprop="name">binpang</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">28</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/bin2415" target="_blank" title="Github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Github
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Interesting-Fuzzing"><span class="nav-number">1.</span> <span class="nav-text">Interesting Fuzzing</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Coverage-based-Greybox-Fuzzing-as-Markov-Chain-CCS-16"><span class="nav-number">1.1.</span> <span class="nav-text">Coverage-based Greybox Fuzzing as Markov Chain(CCS 16)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#T-Fuzz-fuzzing-by-program-transformation-S-amp-P-18"><span class="nav-number">1.2.</span> <span class="nav-text">T-Fuzz: fuzzing by program transformation(S&P 18)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#T-Fuzz-Design"><span class="nav-number">1.2.1.</span> <span class="nav-text">T-Fuzz Design</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CollAFL-Path-Sensitive-Fuzzing-S-amp-P-18"><span class="nav-number">1.3.</span> <span class="nav-text">CollAFL: Path Sensitive Fuzzing(S&P 18)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AFL-Coverage-Measurements"><span class="nav-number">1.3.1.</span> <span class="nav-text">AFL Coverage Measurements</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CollAFL’s-Solution-to-Hash-Collision"><span class="nav-number">1.3.2.</span> <span class="nav-text">CollAFL’s Solution to Hash Collision</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Driller-Argumenting-Fuzzing-Through-Selective-Symbolic-Execution-ndss-16"><span class="nav-number">1.4.</span> <span class="nav-text">Driller: Argumenting Fuzzing Through Selective Symbolic Execution(ndss 16)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VUzzer-Application-aware-Evolutionary-Fuzzing-ndss-17"><span class="nav-number">1.5.</span> <span class="nav-text">VUzzer: Application-aware Evolutionary Fuzzing(ndss 17)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Data-flow-features"><span class="nav-number">1.5.1.</span> <span class="nav-text">Data-flow features</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Control-flow-features"><span class="nav-number">1.5.2.</span> <span class="nav-text">Control-flow features</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Angora-Efficient-Fuzzing-by-Principled-Search-S-amp-P-18"><span class="nav-number">1.6.</span> <span class="nav-text">Angora: Efficient Fuzzing by Principled Search(S&P 18)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Designing-New-Operating-Primitives-to-Improve-Fuzzing-Performance-CCS-17"><span class="nav-number">1.7.</span> <span class="nav-text">Designing New Operating Primitives to Improve Fuzzing Performance(CCS 17)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AFL-Overview"><span class="nav-number">1.7.1.</span> <span class="nav-text">AFL Overview</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#QSYM-A-Practical-Concolic-Execution-Engine-Tailored-for-Hybrid-Fuzzing-Usenix-18"><span class="nav-number">1.8.</span> <span class="nav-text">QSYM: A Practical Concolic Execution Engine Tailored for Hybrid Fuzzing(Usenix 18)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Motivation-Performance-Bottlenecks"><span class="nav-number">1.8.1.</span> <span class="nav-text">Motivation: Performance Bottlenecks</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Slow-Symbolic-Emulation"><span class="nav-number">1.8.1.1.</span> <span class="nav-text">Slow Symbolic Emulation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Ineffective-Snapshot"><span class="nav-number">1.8.1.2.</span> <span class="nav-text">Ineffective Snapshot</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Slow-and-Inflexible-Sound-Analysis"><span class="nav-number">1.8.1.3.</span> <span class="nav-text">Slow and Inflexible Sound Analysis</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Directed-Fuzzing"><span class="nav-number">2.</span> <span class="nav-text">Directed Fuzzing</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Directed-Greybox-Fuzzing-CCS-17"><span class="nav-number">2.1.</span> <span class="nav-text">Directed Greybox Fuzzing(CCS 17)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hawkeye-Towards-a-Desired-Directed-Grey-box-Fuzzer-CCS-18"><span class="nav-number">2.2.</span> <span class="nav-text">Hawkeye: Towards a Desired Directed Grey-box Fuzzer(CCS 18)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Desired-Properties-of-Directed-Fuzzing"><span class="nav-number">2.2.1.</span> <span class="nav-text">Desired Properties of Directed Fuzzing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AFLGo’s-Solution"><span class="nav-number">2.2.2.</span> <span class="nav-text">AFLGo’s Solution</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Suggestions-to-improve-DGFs"><span class="nav-number">2.2.3.</span> <span class="nav-text">Suggestions to improve DGFs:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hawkeye’s-Design"><span class="nav-number">2.2.4.</span> <span class="nav-text">Hawkeye’s Design</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Fuzzing-Machine-Learning-Model"><span class="nav-number">3.</span> <span class="nav-text">Fuzzing Machine Learning Model</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TensorFuzz-Debugging-Neural-Networks-with-Coverage-Guided-Fuzzing-18"><span class="nav-number">3.1.</span> <span class="nav-text">TensorFuzz: Debugging Neural Networks with Coverage-Guided Fuzzing(18)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Coverage-Guided-Fuzzing-for-Deep-Neural-Networks-18"><span class="nav-number">3.2.</span> <span class="nav-text">Coverage-Guided Fuzzing for Deep Neural Networks(18)</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">binpang</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  
    
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "b557b73deba54f66becd4bb20c3a619d",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (search_path.endsWith("json")) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('5');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("iafXwTDO0InSH10OPXAOC3dN-gzGzoHsz", "kOEWGnT0BKyDclixikqG1yRe");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.1"></script>


  

</body>
</html>
